//These functions parse the Bah code. This is the hearth of the compiler.
//Each line type has a parsing function that comes with it.
//A line is not a file line. It starts at the beginning of a file line and ends when the scope is null.
//As such, a line can be 'if a == b{\nreturn 0\n}'.

#include "iostream.bah"

#include "./logger.bah"
#include "./lexer.bah"
#include "./var.bah"
#include "./mem.bah"
#include "./verboseOut.bah"
#include "./cache.bah"
#include "./gen.bah"
#include "./optimizations.bah"
#include "./generics.bah"

comparators = []str{"==", "!=", ">", "<", "<=", ">="}
compSep = []str{"||", "&&"}
signs = []str{"|", "&", "%", "+", "-", "*", "/", "<<", ">>", "^"}
equalsTokens = []str{"=", "+=", "-=", "*=", "/="}


#define parseLine(l []Tok, elems Elems*)

//Only for debug purposes.
debugLine(line []Tok) {
    cont = ""
    i=0; for i < len(line) {
        t = line[i]
        cont += " '" + t.cont + "': "+intToStr(<int>t.type)
        i++
    }
    println(cont)
}

//Duplicates elems (scope).
//Generally used for making an inner/child scope.
dupElems(elems Elems*) Elems* {
    nElems = new Elems {
        parent: elems
        structs: elems.structs
        types: elems.types
        fns: elems.fns
        switchOptCurrLoop: elems.switchOptCurrLoop
    }
    //vars
    allocateArray(nElems.vars, len(elems.vars))
    j=0; for j < len(elems.vars), j++ {
        nElems.vars[j] = elems.vars[j]
    }

    return nElems
}

//All line types
#define lineType int
const LINE_TYPE_NONE         = <lineType>-1
const LINE_TYPE_INCLUDE      = <lineType>0
const LINE_TYPE_DEFINE       = <lineType>1
const LINE_TYPE_CONST        = <lineType>2
const LINE_TYPE_VAR          = <lineType>3
const LINE_TYPE_FN_DECL      = <lineType>4
const LINE_TYPE_FN_CALL      = <lineType>5
const LINE_TYPE_STRUCT       = <lineType>6
const LINE_TYPE_CLIB         = <lineType>7
const LINE_TYPE_RETURN       = <lineType>8
const LINE_TYPE_IF           = <lineType>9
const LINE_TYPE_ELSE         = <lineType>10
const LINE_TYPE_MACRO        = <lineType>11
const LINE_TYPE_FOR          = <lineType>12
const LINE_TYPE_FOR_OPERATOR = <lineType>13
const LINE_TYPE_PRE_KEYWORD  = <lineType>14
const LINE_TYPE_ASYNC        = <lineType>15
const LINE_TYPE_IMPORT       = <lineType>16
const LINE_TYPE_LET          = <lineType>17

prevLine = <lineType>-1

#include "./safety.bah"

//Given a line as tokens array, returns the line type.
getLineType(line []Tok) lineType {

    ft = line[0]

    if ft.type == TOKEN_TYPE_FUNC {
        return LINE_TYPE_FN_CALL
    }
    if ft.type == TOKEN_TYPE_KEYWORD {
        if ft.cont == "#include" {
            return LINE_TYPE_INCLUDE
        } else if ft.cont == "#import" {
            return LINE_TYPE_IMPORT
        } else if ft.cont == "#define" {
            return LINE_TYPE_DEFINE
        } else if ft.cont == "const" {
            return LINE_TYPE_CONST
        } else if ft.cont == "struct" {
            return LINE_TYPE_STRUCT
        } else if ft.cont == "#cLib" {
            return LINE_TYPE_CLIB
        } else if ft.cont == "return" {
            return LINE_TYPE_RETURN
        } else if ft.cont == "if" {
            return LINE_TYPE_IF
        } else if ft.cont == "else" {
            return LINE_TYPE_ELSE
        } else if ft.cont == "#macro" {
            return LINE_TYPE_MACRO
        } else if ft.cont == "for" {
            return LINE_TYPE_FOR
        } else if ft.cont == "async" {
            return LINE_TYPE_ASYNC
        } else if ft.cont == "continue" || ft.cont == "break" {
            return LINE_TYPE_FOR_OPERATOR
        } else if ft.cont == "let" {
            return LINE_TYPE_LET
        } else {
            return LINE_TYPE_PRE_KEYWORD
        }
    } else if ft.type == TOKEN_TYPE_VAR {
        if len(line) > 1 {
            st = line[1]
            if st.type == TOKEN_TYPE_ENCL && st.cont == "(" {
                lt = line[len(line)-1]
                if lt.type == TOKEN_TYPE_ENCL && lt.cont == "}"{
                    return LINE_TYPE_FN_DECL
                }
                return LINE_TYPE_FN_CALL
            }
        }

        return LINE_TYPE_VAR
    }

    return <lineType>-1
}

//Transforms ['<cast>', 'a'] -> 'a' with cast data.
parseCast(line []Tok, elems Elems*, guard bool) []Tok {

    nl = []Tok
    i=0
    if guard == true {
        for i < len(line) {
            t = line[i]
            if t.type == TOKEN_TYPE_CAST {
                break
            }
            nl[i] = t
            i++
        }
        if i == len(line) {
            return line //found no cast in the line, returns it
        }
    }

    for i < len(line), i++ {
        t = line[i]
        if t.type == TOKEN_TYPE_CAST {
            if i + 1 < len(line) { //to make sure we have enough remainning tokens, even a value to cast
                nnnt = line[i+1] //value token
                //type token is enclaved by < and >
                tc = string(t.cont)
                tc.trimLeft(1)
                tc.trimRight(1)
                nnnt.bahType = tc.str()
                cCast = getCType(tc.str(), elems) //converting from Bah type to C type
                cCastStr = cCast.str()
                nnnt.cont = "("+cCastStr+")"+nnnt.cont //C code for casting
                nl[len(nl)] = nnnt //adding the concatenated code to the new line
                i += 2
                continue
            }
        }

        nl[len(nl)] = t //adding token to the new line
    }

    return nl
}

//Returns a directory from a file name.
getDirFromFile(f str) str {
    l int = len(f)
    i = l-1; for i >= 0 {
        c = f[i]
        if c == '/' {
            return f[:i+1]
        }
        i--
    }

    if i <= 0 {
        return ""
    }

    return f
}

//Locates a file that is included/imported.
findFilePath(name str) str {
    fn = absPath(compilerState.currentDir + name)
    if <ptr>fn == null {
        fn = absPath(BAH_DIR + name)
        if <ptr>fn == null {
            return ""
        }
    }
    return fn
}

//Includes a file.
includeFile(ccstr str, elems Elems*) bool {


    needDisableRCP = false

    //includes the correct memory manager file
    if ccstr == "BAH_MEM_COLLECTOR" {
        if lightGCenabled {
            ccstr = "lightgc.bah"
        } else if nativeMemenabled {
            ccstr = "nativeMem.bah"
        } else if RCPenabled == true {
            needDisableRCP = true
            if flags.isSet("rcp") {
                ccstr = "rcp.bah"
            } else if flags.isSet("fastrcp") {
                ccstr = "fastrcp.bah"
            }
        } else {
            ccstr = "gc.bah"
        }
    }

    if isSubObject {
        compilerState.importDeps[len(compilerState.importDeps)] = findFilePath(ccstr)
    }

    //include guard
    if ccstr in compilerState.includes {
        return true
    }

    //open file with Bah directory prefix
    fs = fileStream{}
    fileName = BAH_DIR + ccstr
    isBahDir = true
    fs.open(fileName, "r")
    f = fs.readContent()
    if fs.isValid() == 0 { //try with the current dir instead of Bah dir
        fileName = absPath(compilerState.currentDir + ccstr)
        fs.open(fileName, "r")
        f = fs.readContent()
        isBahDir = false
        if fs.isValid() == 0 {
            return false //file cannot be found
        }
    }
    fs.close()

    //store the current directory
    oDir = compilerState.currentDir
    if isBahDir == false {
        compilerState.currentDir = compilerState.currentDir + getDirFromFile(ccstr)
    } else {
        compilerState.currentDir = BAH_DIR + getDirFromFile(ccstr)
    }

    //stores current file and adds it to the include guard
    oFile = compilerState.currentFile
    compilerState.currentFile = fileName
    compilerState.includes[len(compilerState.includes)] = ccstr

    //reads file
    tokens = lexer(f)
    if len(tokens) == 0 {
        panic("File '"+ccstr+"' not recognized.")
    }

    //handle declarative parsing
    oshd = shouldOnlyDecl
    if isObject == true {
        if isBahDir == true || string(compilerState.currentFile).hasPrefix(oDir) == false {
            shouldOnlyDecl = true
        } else {
            shouldOnlyDecl = false
        }
    } else if isSubObject == true {
        if isBahDir == true || string(compilerState.currentFile).hasPrefix(oDir) == false {
            if isImportedSubObject == true && isBahDir == false {
                shouldOnlyDecl = true
            } else {
                shouldOnlyDecl = false
            }
        } else {
            shouldOnlyDecl = true
        }
    }

    if needDisableRCP == true {
        RCPenabled = false
    }

    parseLines(tokens, elems)

    if needDisableRCP == true {
        RCPenabled = true
    }

    //restore old file's parameters
    shouldOnlyDecl = oshd
    compilerState.currentFile = oFile
    compilerState.currentDir = oDir

    return true
}

//Compiles an object from an imported file.
parallelObjCompile(fn str, oName str, incls []str) {
    cf = getCacheFile(fn)
    scf = cf
    if scf == null {
        scf = new cacheFile
        
    }
    wrkd = getCurrentPath()

    rcp = ""
    if RCPlevel == 1 {
        rcp = "-rcp"
    } else if RCPlevel == 2 {
        rcp = "-fastrcp"
    } else if lightGCenabled {
        rcp = "-lightGC"
    }


    //file not found in cache, need to compile it
    if cf == null || isValidCacheFile(scf) == false {
        verboseCC = ""
        if flags.isSet("verboseCC") == 1 {
            verboseCC = "-verboseCC"
        }
        if debug == false {
            println(ASCII_GREY+"[compiling] "+ASCII_RESET+fn)
        }
        opti = ""
        if isOptimized == true {
            opti = "-optimize"
        }
        nbtin = ""
        if fn == BAH_DIR+"builtin.bah" {
            nbtin = "-nobuiltin"
        }

        setCurrentPath(compilerState.currentDir)
        cmd = command(execName + " "+fn+" "+rcp+" "+opti+" -object "+verboseCC+" "+nbtin+" -o "+oName)
        res = cmd.runBytes()
        setCurrentPath(wrkd)
        if cmd.status != 0 {
            print(arrToStr(res))
            exit(1)
        }
        if cf == null {
            makeCacheFile(fn, incls)
        } else {
            updateCacheFile(cf, incls)
        }
    }
    true -> doneCompilingChan
}

importFile(fileName str, strt Tok*, elems Elems*) {

    if isSubObject {
        compilerState.importDeps[len(compilerState.importDeps)] = findFilePath(fileName)
    }

    if noImport || BAH_OS != BAH_HOST_OS {
        includeFile(fileName, elems)
        return
    }

    //include guard
    if fileName in compilerState.includes {
        return
    }
    compilerState.includes[len(compilerState.includes)] = fileName

    //locates file
    fn = absPath(compilerState.currentDir + fileName)
    if <ptr>fn == null {
        fn = absPath(BAH_DIR + fileName)
        if <ptr>fn == null {
            if strt != null {
                throwErr(strt, "Unknown file {TOKEN}.")
            }
            panic("Could not find std-libs, please check '"+BAH_DIR+"'")
        }
    }

    //set file parameters
    of = compilerState.currentFile
    od = compilerState.currentDir
    compilerState.currentFile = fn
    compilerState.currentDir = getDirFromFile(fn)

    //open file
    fs = fileStream{}
    fs.open(fn, "r")
    f = fs.readContent()
    fs.close()

    //read file
    tokens = lexer(f)

    //sets declarative parsing parameter
    osod = shouldOnlyDecl
    oiso = isSubObject
    oiiso = isImportedSubObject
    ocsimpDeps = compilerState.importDeps

    if isSubObject == true {
        isImportedSubObject = true
    }

    shouldOnlyDecl = true
    isSubObject = true

    oName = BAH_DIR+"cache/"+pathToVarName(fn)+intToStr(RCPlevel)+intToStr(isOptimized)+".o"

    i=len(compilerState.cLibs); for i != 0, i-- {
        compilerState.cLibs[i] = compilerState.cLibs[i-1]
    }

    compilerState.cLibs[0] = "w "+oName+".o" //adds object file to the linker

    compilerState.importDeps = []str

    //parse file
    parseLines(tokens, elems)

    //checks for cache
    currentCompiling++
    async parallelObjCompile(fn, oName, compilerState.importDeps)


    //restore old file's parameters
    shouldOnlyDecl = osod
    isSubObject = oiso
    compilerState.currentFile = of
    compilerState.currentDir = od
    isImportedSubObject = oiiso
    compilerState.importDeps = ocsimpDeps

    //adds its init function
    if isObject == false {
        OUTPUT += rope("void __BAH_init"+pathToVarName(fn)+"();\n")
        INIT += rope("__BAH_init"+pathToVarName(fn)+"();\n")
    }
}

//Parses file import.
parseImport(l []Tok, elems Elems*) {
    compilerState.hasImports = true
    //basic usage check
    if len(l) != 2 {
        throwErr(&l[0], "Invalid usage of {TOKEN}.")
    }
    strt = l[1]
    if strt.type != TOKEN_TYPE_STR {
        throwErr(&strt, "Cannot use {TOKEN} as file name (#import \"file\")")
    }

    //removes quotes from file name
    fileName = strt.cont[1:len(strt.cont)-1]

    importFile(fileName, &strt, elems)
}

//Parses file include.
parseInclude(l []Tok, elems Elems*) {
    //basic usage check
    if len(l) != 2 && len(l) != 3 {
        throwErr(&l[len(l)-1], "Invalid usage of include, ending by {TOKEN}.")
    }
    strt = l[1]
    isSupressed = false
    if strt.cont == "!" &&  len(l) > 2 {
        isSupressed = true
        strt = l[2]
    }
    if strt.type != TOKEN_TYPE_STR {
        throwErr(&strt, "Cannot use {TOKEN} as string in include.")
    }

    //removes quotes from file name
    sc = string(strt.cont)
    sc.trimLeft(1)
    sc.trimRight(1)
    if sc.hasPrefix("<") || sc.hasSuffix(".h") || sc.hasSuffix(".c") { // is a C file
        if isSubObject == false || isSupressed == false {
            throwWarningLine("Including C header file is deprecated. Please #define proper bindings for "+sc.str()+".", strt.line)
            if sc.hasPrefix("<") == false {
                sc.set(strt.cont)
            }
            OUTPUT += rope("#include "+sc.str()+"\n")
            compilerState.cIncludes[len(compilerState.cIncludes)] = sc.str()
        }
    } else { //is a Bah file
        if includeFile(sc.str(), elems) == false {
            throwErr(&strt, "Could not find file {TOKEN}.")
        }
    }
}

#define prePross(line []Tok, ltp lineType, elems Elems*) []Tok

//Parses values of inline struct declaration.
parseStructValues(s cStruct*, isHeap bool, memory []Tok, elems Elems*) variable* {
    sep = "."
    if isHeap {
        sep = "->"
    }


    //preprocess the memory
    if len(memory) > 0 {
        memory = prePross(memory, <lineType>-1, elems)
    }

    declType = 0 //list of members or members by name
    //make temp var
    rvn = genCompilerVar()
    tmpV = new variable
    tmpV.name = rvn
    if isHeap {
        tmpV.type = s.name+"*"
        elems.vars[len(elems.vars)] = tmpV
    } else {
        tmpV.type = s.name
    }
    rst = getCType(tmpV.type, elems)
    r = rope("")
    excl = []int
    j=0;k=0; for k < len(memory) {
        t = memory[k]
        //declaration 'member: value'
        if k+2 < len(memory) {
            st = memory[k+1]
            vl = memory[k+2]
            if st.cont == ":" {
                if declType != 0 && declType != 1 {
                    throwErr(&t, "Cannot declare member {TOKEN} by name in list declaration.")
                }
                declType = 1
                if t.type != TOKEN_TYPE_VAR {
                    throwErr(&t, "Cannot use {TOKEN} as struct member name.")
                }
                j=0; for j < len(s.members) {
                    m = s.members[j]
                    if m.name != t.cont {
                        j++
                        continue
                    }
                    excl[len(excl)] = j
                    if vl.cont == "{" {
                        vs = searchStruct(m.type, elems)
                        if vs == null {
                            throwErr(&vl, "Expected value ("+m.type+"), got struct declaration {TOKEN} instead.")
                        }

                        k += 3
                        start = k
                        nbBraces = 1
                        for k < len(memory), k++ {
                            if memory[k].cont == "{" {
                                nbBraces++
                            } else if memory[k].cont == "}" {
                                nbBraces--
                                if nbBraces == 0 {
                                    break
                                }
                            }
                        }

                        mm = memory[start:k]

                        ntmpV = parseStructValues(vs, isRCPpointerType(m.type), mm, elems)
                        k -= 2

                        vl = Tok {
                            type: TOKEN_TYPE_VAR
                            cont: ntmpV.name
                            bahType: ntmpV.type
                        }

                    }
                    vlt = getTypeFromToken(&vl, true, elems)
                    if compTypes(vlt, m.type) == false {
                        throwErr(&vl, "Cannot use {TOKEN} ("+vlt+") as '"+m.type+"'.")
                    }
                    if RCPavailable() && RCPisTokRef(&vl, vlt, elems) {
                        RCPincrVar(vl.cont, isRCPpointerType(vlt))
                    }
                    r += rope(rvn+sep+m.name+" = "+vl.cont+";\n")
                    break
                }
                if j == len(s.members) {
                    throwErr(&t, "Struct '"+s.name+"' has no member called {TOKEN}.")
                }
                k += 3
                continue
            }
        }
        if declType != 0 && declType != 2 {
            throwErr(&t, "Cannot declare member {TOKEN} without specifying its name.")
        }
        //declaration 'value, value...'
        declType = 2
        if j > len(s.members) {
            throwErr(&t, "Too many members {TOKEN}.")
        }
        m = s.members[j]
        excl[len(excl)] = j
        j++

        if t.cont == "{" {
            vs = searchStruct(m.type, elems)
            if vs == null {
                throwErr(&t, "Expected value ("+m.type+"), got struct declaration {TOKEN} instead.")
            }

            k++
            start = k
            nbBraces = 1
            for k < len(memory), k++ {
                if memory[k].cont == "{" {
                    nbBraces++
                } else if memory[k].cont == "}" {
                    nbBraces--
                    if nbBraces == 0 {
                        break
                    }
                }
            }

            mm = memory[start:k]

            ntmpV = parseStructValues(vs, isRCPpointerType(m.type), mm, elems)

            t = Tok {
                type: TOKEN_TYPE_VAR
                cont: ntmpV.name
                bahType: ntmpV.type
            }

        }

        tt = getTypeFromToken(&t, true, elems)
        if compTypes(tt, m.type) == false {
            throwErr(&t, "Cannot use {TOKEN} ("+tt+") as '"+m.type+"'.")
        }

        r += rope(rvn+sep+m.name+" = "+t.cont+";\n")

        if k+1 < len(memory) {
            k++
            st = memory[k]
            if st.cont != "," {
                throwErr(&st, "Need ',' separator between two values, not {TOKEN}.")
            }
        }
        k++
    }

    //allocate memory
    if isHeap {
        structType = string(rst.str())
        structType.trimRight(1)
        r = rope(rst.str()+" "+rvn+" = memoryAlloc(sizeof("+structType.str()+"));\n"+declareStructMethods(tmpV, excl, s, elems)) + r
    } else {
        r = rope(rst.str()+" "+rvn+" = {};\n"+declareStructMethods(tmpV, excl, s, elems)) + r
    }

    //outputs C code
    if isGlobal() {
        INIT += r
    } else {
        OUTPUT += r
    }

    return tmpV
}

//Parses inline struct declaration.
parseStructType(line []Tok, ltp lineType, elems Elems*) []Tok {
    //vars declaration are handled separatly
    if ltp == LINE_TYPE_VAR {
        return line
    }

    nl = []Tok
    i=0; for i < len(line) {
        t = line[i]
        if t.type == TOKEN_TYPE_VAR {
            //cannot declare struct type for arrays, leaving it to the arrayType handler
            if strHasPrefix(t.bahType, "[]") || (i-1 >= 0 && line[i-1].cont == "map") {
                nl[len(nl)] = t
                i++
                continue
            }
            i++
            nt = Tok{
                cont: ""
            }
            if i < len(line) {
                nt = line[i]
            }
            if i == len(line) || nt.cont != "{" {
                if i-2 >= 0 {
                    newTk = line[i-2]
                    //checking if struct should be declared on the heap or stack
                    if newTk.cont == "new" {
                        s = searchStruct(t.cont, elems)
                        if s == null {
                            throwErr(&t, "Cannot initialize new unknown struct {TOKEN}.")
                        }
                        t.cont = genCompilerVar()
                        tmpV = new variable
                        tmpV.canBeNull = false
                        tmpV.name = t.cont
                        tmpV.type = s.name + "*"
                        cType = getCType(tmpV.type, elems)
                        structType = getCType(s.name, elems)
                        elems.vars[len(elems.vars)] = tmpV

                        r = rope(cType.str()+" "+t.cont+" = memoryAlloc(sizeof("+structType.str()+"));\n"+declareStructMethods(tmpV, null, s, elems))

                        if isGlobal() {
                            INIT += r
                        } else {
                            OUTPUT += r
                        }

                        nl[len(nl)-1] = t
                        continue
                    }
                }
            }
            //declare members
            if i < len(line) {
                nt = line[i]
                if nt.cont == "{" {
                    isHeap = false
                    if i-2 >= 0 {
                        newTk = line[i-2]
                        if newTk.cont == "new" {
                            isHeap = true
                        }
                    }
                    i++
                    s = searchStruct(t.cont, elems)
                    if s == null {
                        throwErr(&t, "Unknown struct name {TOKEN}.")
                    }
                    //store the code inside braces inside memory
                    memory = []Tok
                    nbBraces = 1
                    for i < len(line), i++ {
                        t = line[i]
                        if t.cont == "{" {
                            nbBraces++
                        } else if t.cont == "}" {
                            nbBraces--
                            if nbBraces == 0 {
                                break
                            }
                        }
                        memory[len(memory)] = t
                    }

                    tmpV = parseStructValues(s, isHeap, memory, elems)

                    //makes token with the temp variable
                    t.bahType = tmpV.type
                    t.cont = tmpV.name
                    t.isValue = true
                    if isHeap == true {
                        nl[len(nl)-1] = t
                    } else {
                        t.isDeclared = true
                        nl[len(nl)] = t
                    }
                    i++
                    continue

                } else {
                    i--
                }
            }
        }
        nl[len(nl)] = t
        i++
    }

    return nl
}

//Parses inline arrays declaration.
parseArrayType(line []Tok, elems Elems*) {
    i=0;for i < len(line), i++ {
        t = line[i]
        if t.type == TOKEN_TYPE_ENCL && t.cont[0] == '[' && i+1 < len(line) {
            start = i
            i++
            t = line[i]
            if t.type == TOKEN_TYPE_ENCL && t.cont[0] == ']' {
                i++
                depth = 1
                bracks = "[]"
                for i < len(line) - 1, i+=2 {
                    t = line[i]
                    nt = line[i+1]
                    if t.type == TOKEN_TYPE_ENCL && t.cont[0] == '[' && nt.type == TOKEN_TYPE_ENCL && nt.cont[0] == ']' {
                        depth++
                        bracks += "[]"
                    } else {
                        break
                    }
                }
                if i < len(line) {
                    t = line[i]
                    arrElem = t.cont
                    if t.type != TOKEN_TYPE_VAR {
                        if t.cont != "function" {
                            throwErr(&t, "Cannot use {TOKEN} as array type.")
                        }
                        if i+2 >= len(line) || line[i+1].cont != "(" {
                            throwErr(&line[i], "Invalid usage of {TOKEN}. Expected 'function(argtype,...)returntype'.")
                        }
                        fnPos = i
                        i+=2
                        nbEncl = 1
                        mem = ""
                        for i < len(line), i++ {
                            if line[i].cont == "(" || line[i].cont == "[" {
                                nbEncl++
                            } else if line[i].cont == ")" || line[i].cont == "]" {
                                nbEncl--
                                if nbEncl == 0 {
                                    break
                                }
                            }
                            mem += line[i].cont
                        }

                        if i == len(line) {
                            throwErr(&line[fnPos], "Type {TOKEN} does not end.")
                        }

                        arrElem += "("+mem+")"

                    }
                    deleteRange(line, start+1, i)
                    t.bahType = bracks+arrElem
                    t.cont = ""
                    t.isValue = true
                    line[start] = t
                    continue
                }
            } else {
                i--
            }
        }
    }
}

//Prepends '&' and '*' to var tokens contents.
parsePointers(l []Tok, elems Elems*) []Tok {
    i=0; for i < len(l), i++ {
        t = l[i]
        if t.type == TOKEN_TYPE_SYNTAX && (t.cont[0] == '&' || t.cont[0] == '*') {
            if i > 0 && l[i-1].isValue == true {
                if t.cont[0] == '*' {
                    if i+1 < len(l) {
                        if l[i+1].cont != "(" && l[i+1].type != TOKEN_TYPE_CAST && l[i+1].isValue == false {
                            l[i-1].cont += t.cont
                            delete(l, i)
                            i--
                        }
                    } else {
                        l[i-1].cont += t.cont
                        delete(l, i)
                        i--
                    }
                }
                continue
            }

            if i+1 < len(l) {
                if i > 0 && (l[i-1].cont == ")" || l[i-1].isValue == true) {
                    continue
                }
                if l[i+1].type == TOKEN_TYPE_VAR {
                    if t.cont[0] == '&' {
                        l[i+1].hasAmp = true
                    }
                    l[i+1].cont = t.cont + l[i+1].cont
                    delete(l, i)
                    i--
                }
            }
        }
    }

    return l
}

//OBSOLETE
parseSerialize(e Tok*, elems Elems*) str {


    v = searchVar(e.cont, e, elems)
    if v == null {
        throwErr(&e, "Must be a var, not {TOKEN}.")
    }

    s = searchStruct(v.type, elems)
    if s == null {
        throwErr(&e, "Must be a struct, not {TOKEN}.")
    }

    svt = string(v.type)
    ptrLevel = svt.countChar('*')

    svt.replace("*", "")

    code = ""

    if ptrLevel == 0 {
        code = "__serialize(&" + e.cont + ", " + "sizeof(struct "+svt.str()+")"
    } else {
        ptrRect = ""
        for ptrLevel > 1 {
            ptrRect += "*"
            ptrLevel--
        }
        code = "__serialize(" + ptrRect + e.cont + ", " + "sizeof(struct "+svt.str()+")"
        //is heap allocated, meanning we should calculate real size

        i=0; for i < len(s.members) {
            m = s.members[i]
            if m.type == "str" {
                code += "+strlen("+e.cont+"->"+m.name+")"
            }
            i++
        }

    }


    return code + ")"
}

//Makes a reflection structure from a variable.
parseReflect(t Tok, tt str, elems Elems*, noPointer bool, ogName str, offset str) Tok {

    //If it is a template, pointer will be null.
    if noPointer == false {
        if t.isOper || (t.type != TOKEN_TYPE_VAR && t.type != TOKEN_TYPE_FUNC) {
            t.cont = registerRCPvar(tt, t.cont, elems)
        }

        if t.type == TOKEN_TYPE_STR {
            ogName = "[BAH_STR_LITTERAL]"
        }

        if isRCPpointerType(tt) == false && t.cont != "null" {
            t.cont = "(&" + t.cont + ")"        
        }
    } else {
        t.cont = "null"
    }

    isArr = "0"
    isStruct = "0"
    arrElem = "null"
    structLayout = "null"
    ctt = tt

    //needed to solve infinite reflection on a struct member that is an array of the same elem type than the struct 
    refToProducedReflection = registerRCPvar("reflectElement*", "null", elems) //may not be needed, do not waste an alloc
    needOfProducedReflection = false
    producedRedAllocation = rope("") //to emit the allocation before storing the pointer in reflectElement.arrayElem
    OUTPUT += producedRedAllocation //emit empty for now

    if strHasPrefix(tt, "[]") {
        ctt = "Bah_Array_Type"
        isArr = "1"
        aeType = tt[2:]
        tmpT = Tok {
            type: TOKEN_TYPE_VAR
            cont: "null"
        }

        //need to allocate to keep the template of the reflected object in heap not in stack
        arrElemReflection = parseReflect(tmpT, aeType, elems, true, "", "0").cont //store in stack
        arrElem = registerRCPvar("reflectElement*", "memoryAlloc(sizeof(struct reflectElement))", elems) //allocate heap
        OUTPUT += rope("* "+arrElem + " ="+arrElemReflection+";") //copy stack memory un the heap space
    } else {
        let s = searchStruct(tt, elems) then {
            isStruct = "1"
            structLayout = registerRCPvar("[]reflectElement", "memoryAlloc(sizeof(struct Bah_Array_Type));", elems)
            OUTPUT += rope(structLayout + "->elemSize = sizeof(struct reflectElement);
            "+structLayout + "->length = "+uintToStr(len(s.members))+";
            "+structLayout + "->realLength = "+uintToStr(len(s.members))+";
            "+structLayout + "->data = memoryAlloc(sizeof(struct reflectElement) * "+uintToStr(len(s.members))+");")
            ctt = s.name

            snPtr = s.name+"*"

            i=0; for i < len(s.members), i++ {
                m = s.members[i]
                
                //prevent inifinte reflection
                if strHasPrefix(m.type, snPtr) {
                    nm = new structMemb
                    *nm = *m
                    nm.type = "ptr"
                    m = nm
                } else if strHasPrefix(m.type, "[]"+snPtr) {
                    nm = new structMemb
                    *nm = *m
                    nm.type = "[]ptr"
                    m = nm
                }

                tmpT = Tok {
                    type: TOKEN_TYPE_VAR
                    isOper: true
                }

                sep = "->"

                mCtype = getCType(m.type, elems).str()
                mOffset = "offsetof(struct "+s.name+", "+m.name+")"

                tmpT.cont = "0"
                tmpT = parseReflect(tmpT, m.type, elems, true, m.name, mOffset)


                OUTPUT += rope("((struct reflectElement*)"+structLayout+"->data)["+intToStr(i)+"] = "+tmpT.cont+";\n")
            }

            i=0; for i < len(s.members), i++ {
                m = s.members[i]
                if strHasPrefix(m.type, snPtr) {
                    OUTPUT += rope("((struct reflectElement*)"+structLayout+"->data)["+intToStr(i)+"].structLayout = "+structLayout+";
                    ((struct reflectElement*)"+structLayout+"->data)["+intToStr(i)+"].type = "+strLitteralToBahStr("\""+m.type+"\"")+";
                    ((struct reflectElement*)"+structLayout+"->data)["+intToStr(i)+"].isStruct = true;
                    ((struct reflectElement*)"+structLayout+"->data)["+intToStr(i)+"].size = sizeof(struct "+s.name+");")
                } else if strHasPrefix(m.type, "[]"+snPtr) {
                    needOfProducedReflection = true
                    OUTPUT += rope("
                    ((struct reflectElement*)"+structLayout+"->data)["+intToStr(i)+"].type = "+strLitteralToBahStr("\""+m.type+"\"")+";
                    ((struct reflectElement*)"+structLayout+"->data)["+intToStr(i)+"].isArray = true;
                    ((struct reflectElement*)"+structLayout+"->data)["+intToStr(i)+"].arrayElem = "+refToProducedReflection+";
                    ((struct reflectElement*)"+structLayout+"->data)["+intToStr(i)+"].size = sizeof(struct Bah_Array_Type);")
                }
            }

        }
    }

    if ctt == tt {
        ctt = strReplace(ctt, "*", "")
    }

    t.cont = registerRCPvar("reflectElement", "__reflect("+t.cont+", sizeof("+getCType(ctt, elems).str()+"),
    "+strLitteralToBahStr("\""+tt+"\"")+", "+strLitteralToBahStr("\""+ogName+"\"")+", "+isArr+",
    "+arrElem+", "+isStruct+", "+structLayout+", "+offset+")", elems)

    
    if needOfProducedReflection {
        ropeSet(producedRedAllocation, refToProducedReflection+" = memoryAlloc(sizeof(struct reflectElement));")
        OUTPUT += rope("*"+refToProducedReflection+" = "+t.cont+";")
    }

    return t
}

//Parses array declarations such as: 'a = []type'.
parseArrayDecl(v variable*, l []Tok, i uint, max uint, elems Elems*) str {
    arrayLength = 0
    arrType = getCType(v.type[2:], elems)
    code = "memoryAlloc(sizeof(struct Bah_Array_Type))"
    elemTypeStr = arrType.str()

    if i + 1 != max {
        i++
        nt = l[i]
        if nt.cont != "{" {
            throwErr(&l[i+1], "{TOKEN} not expected after array initialization.")
        }
        elemBahType = string(v.type)
        elemBahType.trimLeft(2)
        elemBahTypeStr = elemBahType.str()
        i++
        memory = []Tok
        for i < max {
            memory[len(memory)] = l[i]
            i++
        }
        memory = prePross(memory, <lineType>-1, elems)
        i=0; for i < len(memory) {
            t = memory[i]
            if t.cont == "{" {

                j=i-1
                nbBraces = 0
                for i < len(memory), i++ {
                    tmpT = memory[i]
                    if tmpT.cont == "{" {
                        nbBraces++
                    } else if tmpT.cont == "}" {
                        nbBraces--
                    }
                    if nbBraces == 0 {
                        break
                    }
                }
                tmpV = new variable
                tmpV.name = genCompilerVar()
                elemType = string(v.type)
                elemType.trimLeft(2)
                tmpV.type = elemType.str()
                elems.vars[len(elems.vars)] = tmpV

                oldNL = NEXT_LINE
                NEXT_LINE = ""
                innerCode = parseArrayDecl(tmpV, memory, j, i+1, elems)
                r = rope("
                struct Bah_Array_Type * "+tmpV.name+" = "+innerCode+";
                "+NEXT_LINE+"
                ")
                if isGlobal() {
                    INIT += r
                } else {
                    OUTPUT += r
                }
                NEXT_LINE = oldNL

                t = Tok{
                    type: TOKEN_TYPE_VAR
                    cont: tmpV.name
                    bahType: elemType.str()
                    isValue: true
                }

            }
            tt = getTypeFromToken(&t, true, elems)
            if compTypes(tt, elemBahTypeStr) == false {
                throwErr(&t, "Cannot use {TOKEN} ("+tt+") as "+elemBahTypeStr)
            }

            strArrayLength = intToStr(arrayLength)
            arrayLength++

            NEXT_LINE += "(("+elemTypeStr+"*)" + v.name + "->data)[" + strArrayLength + "] = " + t.cont + ";\n"
            i++
            t = memory[i]

            if t.cont != "," {
                if t.cont == "}" {
                    allocLength = arrayLength
                    if allocLength > 50 {
                        modAllocAmm = allocLength % 50
                        allocLength += modAllocAmm
                    } else {
                        allocLength = 50
                    }
                    allocLengthStr = intToStr(allocLength)

                    if isRCPtype(v.type[2:], elems) == false {
                        NEXT_LINE = v.name + "->data = memoryAllocAtomic(sizeof(" + elemTypeStr + ") * " + allocLengthStr + ");
                        "+v.name+"->realLength = " + allocLengthStr + ";\n" + NEXT_LINE
                    } else {
                        NEXT_LINE = v.name + "->data = memoryAlloc(sizeof(" + elemTypeStr + ") * " + allocLengthStr + ");
                        "+v.name+"->realLength = " + allocLengthStr + ";\n" + NEXT_LINE

                    }

                    break
                } else {
                    throwErr(&t, "Expected ',' got {TOKEN}.")
                }
            }
            i++
        }
    }
    strArrayLength = intToStr(arrayLength)
    name = v.name

    if v.isArray {
        ar Tok* = v.arrRoot
        ai Tok* = v.arrIndex
        name = "(("+getCType(v.type, elems).str()+"*)" +ar.cont + "->data)["+ai.cont+"]"
    }

    NEXT_LINE = "
" + name + "->length = " + strArrayLength + ";
" + name + "->elemSize = sizeof(" + elemTypeStr + ");
" + NEXT_LINE
    return code
}

//Parses var declaration and usage.
parseVar(l []Tok, elems Elems*) {
    ft = l[0]
    if ft.isFunc == true {
        if len(l) > 1 {
            throwErr(&l[1], "Not expecting {TOKEN} after a read-only statement.")
        }
        ft = l[0]
        parsed = true

        if RCPavailable() {
            let fn = searchVirtFuncByToken(&ft, elems) then {
                if isRCPtype(fn.returns.type, elems) {
                    ft.cont = "RCP_decr("+ft.cont+", 0)"
                }
            }
        }


        OUTPUT += rope(ft.cont + ";\n")
        return
    }
    parseArrayType(l, elems)
    l = parseStructType(l, <lineType>-1, elems)
    isEqual = false
    equalIndex = 0
    toVar = false
    isPointedVar = false
    isStruct = false
    currentType = ""
    // needsDefine = false
    ft = l[0]
    exists = true

    // v = searchVirtVarByToken(&ft, elems)
    // if v == null {
    //     if ft.getRefVar() != null {
    //         v = ft.getRefVar()
    //     } else {
    //         exists = false
    //         v = new variable
    //         v.name = ft.cont
    //         v.type = ""
    //     }
    // }

    let v = searchVirtVarByToken(&ft, elems) else {
        if ft.getRefVar() != null {
            v = ft.getRefVar()
        } else {
            exists = false
            v = new variable
            v.name = ft.cont
            v.type = ""
        }
        if v == null {
            return
        }
    }

    if v.isConst == true {
        throwErr(&ft, "Cannot set the value of const {TOKEN}.")
    }
    code = ""

    if exists == true && isGlobal() {
        throwErr(&ft, "Cannot redeclare global variable {TOKEN}.")
    }


    if len(l) == 1 {
        t = l[0]
        v = searchVirtVarByToken(&t, elems)
        if v == null {
            throwErr(&t, "Lost variable {TOKEN}.")
        }
        rv = getRealVar(v.name, elems)
        if rv != null {
            rv.lastSet = elems
        }
        OUTPUT += rope(t.cont + ";\n")
        return
    }

    if len(l) < 2 {
        throwErr(&ft, "Missing '=' after {TOKEN}.")
    }
    operT = l[1]
    if operT.cont in equalsTokens && operT.cont != "=" {
        nl = []Tok{l[0]}
        if 2 == len(l) {
            throwErr(&operT, "Cannot use {TOKEN} on nothing.")
        }
        oper = string(operT.cont)
        oper.trimRight(1)
        operTok = operT
        operTok.cont = oper.str()

        if l[2].isOper {
            l[2].cont = "("+l[2].cont+")"
        }

        tmpL = []Tok {
            ft,
            operTok,
            l[2]
        }

        currSetVar = v

        tmpL = prePross(tmpL, LINE_TYPE_VAR, elems)
        currSetVar = null

        operT.cont = "="
        nl[len(nl)] = operT

        j=0; for j < len(tmpL), j++ {
            nl[len(nl)] = tmpL[j]
        }


        l = nl
    }

    i=1; for i < len(l) {
        t = l[i]
        if t.type == TOKEN_TYPE_SYNTAX {
            if t.cont == "=" {
                if len(currentType) > 0 {
                    sct = string(currentType)
                    sct.replace(" ", "")
                    v.type = sct.str()
                }
                isEqual = true
                equalIndex = i
                i++
                continue
            }
        }
        if isEqual == false {
            if t.type != TOKEN_TYPE_KEYWORD && t.type != TOKEN_TYPE_VAR && (t.cont != ":" && t.cont != "(" && t.cont != ")") || t.isFunc || t.isOper {
                throwWarningLine("You may have forgotten '=' between "+v.name+" and "+t.ogCont+".", t.line)
                throwErr(&t, "Cannot use {TOKEN} as type.")
            }
            currentType += t.cont
        } else {

            if t.isDeclared && exists == false && isGlobal() == false {
                // needsDefine = true
                v.canBeNull = false
            }

            if t.cont == "chan" {
                if i >= len(l) {
                    throwErr(&t, "Cannot declare a {TOKEN} without a type (chan <type>).")
                }
                i++
                nt = l[i]
                v.type = "chan:" + nt.cont
                code = "channel()"
                if i+1 != len(l) {
                    errT = l[i+1]
                    throwErr(&errT, "{TOKEN} not expected after channel declaration.")
                }
                break
            } else if t.cont == "map" {
                if i >= len(l) {
                    throwErr(&t, "Cannot declare a {TOKEN} without a type (map <type>).")
                }
                i++
                nt = l[i]
                v.type = "map:"+nt.cont
                code = "mapWrapper()"
                if i+1 != len(l) {
                    if l[i+1].cont != "{" {
                        throwErr(&l[i+1], "{TOKEN} not expected after map declaration, initialize the map with values '{}' ?")
                    }
                    i += 2
                    nbBraces = 1
                    start = i
                    for i < len(l), i++ {
                        if l[i].type != TOKEN_TYPE_ENCL {
                            continue
                        }
                        if l[i].cont == "{" {
                            nbBraces++
                        } else if l[i].cont == "}" {
                            nbBraces--
                        }

                        if nbBraces == 0 {
                            break
                        }
                    }

                    if i - start == 0 {
                        break
                    }

                    memory = prePross(l[start:i], <lineType>-1, elems)
                    
                    j=0; for j < len(memory), j += 4 {
                        key = memory[j]
                        if j+2 >= len(memory) {
                            throwErr(&key, "Invalid syntax for declaring key {TOKEN}, expected 'key: value'.")
                        }
                        value = memory[j+2]

                        kt = getTypeFromToken(&key, true, elems)
                        if kt != "str" {
                            throwErr(&key, "Cannot use {TOKEN} as map key (str).")
                        }

                        if memory[j+1].cont != ":" {
                            throwErr(&memory[j+1], "Expected ':' not {TOKEN}.")
                        }

                        vlt = getTypeFromToken(&value, true, elems)
                        if compTypes(vlt, nt.cont) == false {
                            throwErr(&value, "Cannot use {TOKEN} ("+vlt+") as map value ("+nt.cont+").")
                        }

                        if j+4 < len(memory) && memory[j+3].cont != "," {
                            throwErr(&memory[j+1], "Expected ',' between map values not {TOKEN}.")
                        }

                        if isRCPpointerType(vlt) {
                            NEXT_LINE += v.name+"->set("+v.name+", "+key.cont+", "+value.cont+");\n"
                        } else {
                            pntVarName = registerRCPvar(vlt, value.cont, elems)
                            NEXT_LINE += "mapWrapper__setAny("+v.name+", "+key.cont+", &"+pntVarName+", sizeof("+getCType(vlt, elems).str()+"));\n"
                        }
                        
                    }


                }


                break
            } else if t.cont == "buffer" {
                if i >= len(l) {
                    throwErr(&t, "Cannot declare a {TOKEN} without a length (buffer <length>).")
                }
                i++
                nt = l[i]
                if nt.type != TOKEN_TYPE_INT {
                    throwErr(&nt, "Expected buffer length, not {TOKEN}.")
                }
                v.type = "buffer:"+nt.cont
                av = new variable
                av.type = "char*"
                av.name = genCompilerVar()
                elems.vars[len(elems.vars)] = av
                cType = getCType(av.type, elems)
                OUTPUT += rope("char "+av.name+"["+nt.cont+"];")
                code = av.name
                if i+1 != len(l) {
                    errT = l[i+1]
                    throwErr(&errT, "{TOKEN} not expected after buffer declaration.")
                }
                break
            }


            tp = getTypeFromToken(&t, true, elems)

            //safety check to know if it is possible that the declared/set variable can contain a null pointer
            if isUnsafe == false && string(compilerState.currentDir).hasPrefix(BAH_DIR) == false && isRCPpointerType(tp) && v.isArray == false {
                if t.cont == "null" || tp[len(tp)-1] == '!' {
                    if exists {
                        rv = getRealVar(v.name, elems)
                        if rv != null {
                            rv.canBeNull = true
                        }
                    } else {
                        v.canBeNull = true
                    }
                } else if t.type == TOKEN_TYPE_VAR && t.isOper == false {
                    tv = searchVirtVarByToken(&t, elems)
                    if tv != null {
                        if exists == true && tv.canBeNull == false {
                            if canChangeNullState(v, elems) {
                                rv = getRealVar(v.name, elems)
                                if rv != null {
                                    rv.canBeNull = false
                                }
                            } else {
                                j=0; for j < len(elems.branchChecks), j++ {
                                    if elems.branchChecks[j].v == null {
                                        continue
                                    }
                                    if elems.branchChecks[j].v.name == v.name {
                                        elems.branchChecks[j].checkNull = false
                                        break
                                    }
                                }
                                if j == len(elems.branchChecks) {
                                    elems.branchChecks[len(elems.branchChecks)] = varCheck {
                                        v: v
                                        checkNull: false
                                    }
                                }
                            }
                        } else {
                            v.canBeNull = tv.canBeNull
                        }
                    }
                } else if t.isFunc == true {
                    fn = searchFuncByToken(&t, elems)
                    if fn != null && fn.returns != null {
                        if fn.returns.canBeNull == true {
                            v.canBeNull = true
                        } else {
                            if exists == true {
                                if canChangeNullState(v, elems) {
                                    v.canBeNull = false
                                }
                            } else {
                                v.canBeNull = false
                            }
                        }
                    }
                } else {
                    if exists == true {
                        if canChangeNullState(v, elems) {
                            rv = getRealVar(v.name, elems)
                            if rv != null {
                                rv.canBeNull = false
                            }
                        }
                    } else {
                        v.canBeNull = false
                    }
                }
            }

            //type checking
            if exists == true {
                if compTypes(tp, v.type) == false {
                    throwErr(&t, "Cannot use {TOKEN} ("+tp+") as "+v.type+".")
                }
            } else {
                if currentType == "" {
                    if v.type == "" {
                        v.type = tp
                    } else {
                        if compTypes(tp, v.type) == false {
                            throwErr(&t, "Cannot use {TOKEN} ("+tp+") as "+v.type+".")
                        }
                    }
                }
            }

            if RCPavailable() && isRCPtype(v.type, elems) {
                if RCPisTokRef(&t, tp, elems) && t.cont != "null" {
                    RCPincrVar(t.cont, isRCPpointerType(v.type))
                }
                if v.isArray == false && exists {
                    RCPdecrVar(ft.cont, isRCPpointerType(tp))
                }
            }

            if isTupleType(tp) {
                if t.type == TOKEN_TYPE_VAR && t.ogCont[0] != '[' {
                    size = getTupleSize(tp, elems)
                    tmpV = genCompilerVar()
                    code = "memoryAlloc("+size+")"
                    NEXT_LINE += "memcpy("+v.name+", "+t.cont+", "+size+");\n"
                    i++;continue
                } else if exists && v.declScope != elems && v.canBeNull == false {
                    code = ft.cont
                    size = getTupleSize(tp, elems)
                    NEXT_LINE += "if ("+v.name+"==null) {
                        "+v.name+" = memoryAlloc("+size+");
                    }
                    memcpy("+v.name+", "+t.cont+", "+size+");\n"
                    i++; continue
                }
            }

            if t.cont != "" && strHasPrefix(t.cont, "{") == false {
                code += t.cont
                break
            }


            if strHasPrefix(v.type, "[]") {
                code = parseArrayDecl(v, l, i, len(l), elems)
                break
            }
            isStruct = true
            if i+1 != len(l) {
                throwErr(&l[i+1], "{TOKEN} not expected after struct initialization.")
            }
            // s = searchStruct(v.type, elems)
            // NEXT_LINE = declareStructMethods(v, s, elems)
            code += t.cont
        }

        i++
    }

    if exists == true {

        //safety
        rv = getRealVar(v.name, elems)
        if rv != null && isStaticToken(&l[equalIndex+1], elems) == false {
            rv.lastSet = elems
            if l[equalIndex+1].type == TOKEN_TYPE_VAR {
                vv = searchVirtVarByToken(&l[equalIndex+1], elems)
                if vv != null {
                    rv.lastSet = vv.lastSet
                }
            }
        }

        if ft.parent != null {
            ft.parent.lastSet = elems
        }
        if currentFn != null {
            if v.name == "this" || string(v.name).hasPrefix("this->") {
                currentFn.isMut = true
            }
        }
        if len(code) == 0 {
            throwErr(&ft, "Cannot re-declare {TOKEN}.")
        }
        if len(currentType) > 0 {
            st = l[1]
            throwErr(&st, "Cannot change the type of already declared var '"+ft.cont+"' to {TOKEN}.")
        }
        preCode = ""
        val = code
        if isStruct == false {
                s = searchStruct(v.type, elems)
                code = l[0].cont + " = " + code
        } else {
            strTrim(&code)
            if strHasPrefix(code, "{") == false {
                code = l[0].cont + " = " + code
            }
        }
        if v.isArray == true {
            code = genArrRealloc(v, preCode, val, elems)
        } else {
            code = preCode + code
        }
    } else {
        if currentType != "" {
            v.type = currentType
        }

        if len(code) == 0 {
            v.canBeNull = true
        }

        vts = string(v.type)
        vts.replace(" ", "")
        v.type = vts.str()
        if len(v.type) == 0 {
            throwErr(&ft, "Cannot declare {TOKEN} without a type.")
        }
        vct = ""
        if vts.hasPrefix("function(") {
            vct = getCfunctionType(&vts, l[0].cont, elems)
        } else {
            vct = setCType(v, elems)
        }
        if code != "" && shouldOnlyDecl == false {
            if isGlobal() {
                INIT += rope(l[0].cont + " = " + code+";\n")
            } else {
                code = vct + " = " + code
            }
        } else {
            if isRCPpointerType(v.type) && shouldOnlyDecl == false  {
                code = vct + "= null"
            } else {
                code = vct
            }
        }

        if shouldOnlyDecl == true {
            vct = "extern "+vct
        }

        if isGlobal() {
            v.isGlobal = true
        } else {
            v.isGlobal = false
        }
        v.declScope = elems
        elems.vars[len(elems.vars)] = v

        if fixMeEnabled() {
            fixMeRegisterVar(v, &ft)
        }

        dv = debugVar{}
        dv.fromVar(v)
        debugPrint("var_declaration", ft.line, &dv)
        // registerType(&fileDeps, v.type, elems)

        if isGlobal() {
            OUTPUT += rope(vct+";\n")
        }
    }

    if isGlobal() {
        if isSubObject == false {
            INIT += rope(NEXT_LINE)
        }
        NEXT_LINE = ""
    } else {
        declR = rope(code + ";\n")
        if exists == false {
            //for optimizations
            v.declRope = declR
            v.canBeReg = true
        }
        OUTPUT += declR
        // if v.type == "str" {
        //     makeStrlenVar(v, elems)
        // }
    }

}

//Parses function definition header in function declaration.
//Returns [the fn header in C, delcaration dependencies]
parseFnHeader(prev str, l []Tok, i int*, fn func*, lambda bool, elems Elems*) [str,str] {

    tpdf = ""
    j = *i
    if lambda == false {
        ft = l[j]
        if ft.type != TOKEN_TYPE_VAR {
            throwErr(&ft, "Cannot use {TOKEN} as function name.")
        }
        fn.name = prev + ft.cont
        j += 2
    } else {
        fn.name = "__lambda_"+genCompilerVar()
        j++
    }

    arguments = []variable*

    code = fn.name + "("

    t = l[j]
    if t.cont != ")" {

        for j < len(l) {
            t = l[j]
            if t.type != TOKEN_TYPE_VAR {
                throwErr(&t, "Cannot use {TOKEN} as argument name.")
            }
            argName = t.cont

            j++
            if j >= len(l) {
                throwErr(&t, "Cannot declare argument {TOKEN} without a type.")
            }
            t = l[j]
            argType = t.cont

            if t.cont[0] == '[' {
                nbEncl = 1
                j++
                for j < len(l), j++ {
                    argType += l[j].cont
                    if l[j].cont == "[" || l[j].cont == "(" || l[j].cont == "{" {
                        nbEncl++
                    } else if l[j].cont == "]" || l[j].cont == ")" || l[j].cont == "}" {
                        nbEncl--
                        if nbEncl == 0 {
                            break
                        }
                    }
                }
            }


            j++
            isComa = false
            nbPars = 1
            for j < len(l), j++ {
                t = l[j]
                isComa = false
                if t.cont == "(" {
                    nbPars++
                } else if t.cont == ")" {
                    nbPars--
                    if nbPars == 0 {
                        break
                    }
                } else if t.cont == "," && nbPars == 1 {
                    isComa = true
                    break
                }

                argType += t.cont
            }

            argument = new variable
            argument.name = argName
            argument.type = argType
            arguments[len(arguments)] = argument


            argCType = getCType(argType, elems)

            cfrt = string(argType)
            newArgType = argCType.str()
            if cfrt.hasPrefix("function(") == 1 {
                code += getCfunctionType(&cfrt, argName, elems)
            } else {
                code += newArgType + " " + argName
            }
            if isComa == true {
                code += ","
            } else {
                code += ")"
                break
            }
            j++
        }
    } else {
        code += ")"
    }

    j++

    returns = new variable
    returns.type = ""
    for j < len(l) {
        t = l[j]
        if (lambda == false && t.cont == "{") || (lambda == true && t.cont == "=>") {
            break
        }
        returns.type = returns.type + t.cont
        j++
    }
    if len(returns.type) {
        rts = string(returns.type)
        rts.replace(" ", "")
        returns.type = rts.content
    }

    if len(returns.type) > 1 && returns.type[0] == '[' && returns.type[len(returns.type)-1] == ']' {
        coma = ""
        if len(arguments) > 0 {
            coma = ", "
        }
        code = code[:len(code)-1] + coma+"void* __BAH_TUPLE_RET_PTR)"
    }

    *i = j
    returns.name = fn.name
    fn.returns = returns
    fn.args = arguments

    crt = ""
    if len(returns.type) > 0 && returns.type[len(returns.type)-1] == '!' {
        crt = "void*"
    } else {
        crt = getCType(returns.type, elems).str()
    }
    code = crt + " " + code
    return [code,tpdf]
}

//Parses struct type definition.
parseStruct(l []Tok, elems Elems*) {
    s = new cStruct
    structs = elems.structs
    structs[len(structs)] = s
    methds = s.methods
    if len(l) < 4 {
        throwErr(&l[len(l)-1], "Cannot declare struct has such, please do 'struct <name> { <memberName>:<memberType> }'.")
    }
    nameToken = l[1]
    i = 2
    doesOutput = true
    if nameToken.cont == "!" {
        nameToken = l[2]
        i = 3
        doesOutput = false
        s.isBinding = true
    }
    if nameToken.type != TOKEN_TYPE_VAR {
        throwErr(&nameToken, "Cannot use {TOKEN} as struct name.")
    }
    os = searchStruct(nameToken.cont, elems)
    if os != null {
        throwErr(&nameToken, "Struct {TOKEN} already exists.")
    }
    s.name = nameToken.cont
    members = s.members
    currentCStruct = s
    allMembs = []str
    st = l[i]
    if st.type == TOKEN_TYPE_KEYWORD {
        if st.cont == "extend" {
            i++
            extdSNameTk = l[i]
            i++
            if extdSNameTk.type != TOKEN_TYPE_VAR {
                throwErr(&extdSNameTk, "Cannot use {TOKEN} as struct name.")
            }
            extdS = searchStruct(extdSNameTk.cont, elems)
            if extdS == null {
                throwErr(&extdSNameTk, "Struct {TOKEN} does not exist.")
            }
            s.extendedFrom = extdS.name
            s.hasRCPmemb = extdS.hasRCPmemb
            extdsmbs = extdS.members
            j=0; for j < len(extdsmbs) {
                em = extdsmbs[j]
                cemt = string(em.type)
                membDeclStr str
                if cemt.hasPrefix("function(") == 1 {
                    membDeclStr = getCfunctionType(&cemt, em.name, elems)
                } else {
                    membDecl = getCType(em.type, elems)
                    membDecl.append(" ")
                    membDecl.append(em.name)
                    membDeclStr = membDecl.content
                }
                allMembs[len(allMembs)] = membDeclStr
                members[len(members)] = em
                j++
            }
        } else {
            throwErr(&st, "Cannot use keyword {TOKEN} in struct declaration.")
        }
    }
    braceTk = l[i]
    i++
    if braceTk.cont != "{" {
        throwErr(&braceTk, "Cannot use {TOKEN} in struct declaration.")
    }
    postDeclHandle = rope("")
    OUTPUT += postDeclHandle
    OOUT = OUTPUT
    nextLine = ""
    bottomDecl = rope("")
    j=0; for j < len(l), j++ {
        if l[j].type == TOKEN_TYPE_STR && l[j].processedStr == false {
            l[j].cont = strLitteralToBahStr(l[j].cont)
            l[j].processedStr = true
        }
    }
    for i < len(l) {
        t = l[i]
        max = i + 2
        if max >= len(l) {
            if t.type == TOKEN_TYPE_ENCL && t.cont == "}" {
                break
            }
            throwErr(&l[len(l)-1], "Not enough argument in member declaration, ending by {TOKEN}.")
        }
        memb = new structMemb
        if t.type != TOKEN_TYPE_VAR {
            throwErr(&t, "Cannot use {TOKEN} as member name.")
        }
        memb.name = t.cont
        ii=0; for ii < len(members) {
            m = members[ii]
            if m.name == memb.name {
                throwErr(&t, "Member {TOKEN} has already been declared.")
            }
            ii++
        }
        i++
        t = l[i]
        if t.cont != ":" {
            if t.cont != "(" {
                throwErr(&t, "Member name should be followed by ':' not {TOKEN}.")
            } else {
                declT = t
                fnPrefix = s.name + "__"
                fn = new func
                nl = []Tok
                j=i-1; for j < len(l) {
                    t = l[j]
                    if t.cont == "{" {
                        break
                    }
                    nl[len(nl)] = t
                    if j == i {
                        t.type = TOKEN_TYPE_VAR
                        t.cont = "this"
                        t.isValue = true
                        nl[len(nl)] = t

                        t.type = TOKEN_TYPE_VAR
                        t.cont = s.name+"*"
                        t.isValue = true
                        nl[len(nl)] = t

                        nt = l[j+1]
                        if nt.cont != ")" {
                            t.type = TOKEN_TYPE_SYNTAX
                            t.cont = ","
                            t.isValue = false
                            nl[len(nl)] = t
                        }
                    }
                    j++
                }
                i--

                nli = 0

                header = parseFnHeader(fnPrefix, nl, &nli, fn, false, elems)
                code = rope(header[0])
                headerDecl = header[1] + code.toStr()
                i += nli
                i -= 2

                returns = fn.returns
                arguments = fn.args
                fn.from = s.name
                if shouldOnlyDecl == true {
                    code += rope(";\n")
                } else {
                    code += rope("{\n")
                }

                fnElems = dupElems(elems)
                j=0; for j < len(arguments), j++ {
                    a = arguments[j]
                    a.declScope = elems
                    a.isArg = true
                    fnElems.vars[len(fnElems.vars)] = a
                }

                fns = elems.fns
                fns[len(fns)] = fn

                if debug == true {
                    df = new debugFunction
                    df.name = fn.name
                    j=0; for j < len(fn.args), j++ {
                        dfa = new debugVar
                        dfa.fromVar(fn.args[j])
                        df.args[j] = dfa
                    }
                    df.returns = fn.returns.type
                    debugPrint("fn_declare", declT.line, df)
                }

                tokens = []Tok
                nbBraces = 1
                t = l[i]
                if t.cont == "{" {
                    i++
                }
                start = i
                tokens = <[]Tok>null
                for i < len(l), i++ {
                    t = l[i]
                    if t.cont == "{" {
                        nbBraces++
                    } else if t.cont == "}" {
                        nbBraces--
                        if nbBraces == 0 {
                            break
                        }
                    }
                }

                if shouldOnlyDecl == false {
                    tokens = l[start:i]
                }


                mfn = new func
                mfn.args = fn.args
                mfn.name = fn.name[len(fnPrefix):]
                mfn.returns = fn.returns
                mfn.from = s.name

                methds[len(methds)] = mfn

                if shouldOnlyDecl == false {
                    if len(tokens) == 0 {
                        code += rope("};\n")
                    } else {
                        OUTPUT = rope("")
                        currentFn = fn
                        ocurrFnElems = compilerState.currFnElems
                        compilerState.currFnElems = fnElems
                        parseLines(tokens, fnElems)
                        RCPendScope(fnElems)
                        OPTI_checkFuncScopeRef(fnElems)
                        compilerState.currFnElems = ocurrFnElems

                        currentFn = null
                        if fn.returned == false {
                            if len(fn.returns.type) > 0 {
                                throwErr(&l[len(l)-1], "Function '"+fn.name+"' is not returned.")
                            }
                            fixMeEndScope(fnElems, &tokens[len(tokens)-1])
                        }
                        code += OUTPUT + rope("};\n")
                    }
                } else {
                    fn.isImported = true; mfn.isImported = true;
                }

                if doesOutput == true {
                    bottomDecl += rope(headerDecl+";\n")
                    nextLine += code.toStr()
                }

                i++
                continue

            }
        }
        i++
        mbmType = ""
        currentLine = t.line
        for i < len(l) {
            t = l[i]
            if t.cont == "=" {
                i--
                break
            }
            if t.line != currentLine {
                i--
                break
            }
            mbmType += t.cont
            i++
        }

        memb.type = mbmType
        i++
        t = l[i]
        if i < len(l) {
            if t.cont == "=" {
                i++
                t = l[i]
                if t.isValue == false {
                    throwErr(&t, "Cannot use {TOKEN} as default value for member.")
                }
                tt = getTypeFromToken(&t, true, elems)
                if compTypes(tt, memb.type) == false {
                    throwErr(&t, "Cannot use {TOKEN} ("+tt+") as "+memb.type+" for member.")
                }
                memb.def = t.cont

            } else {
                i--
            }
        }
        if isRCPtype(memb.type, elems) {
            s.hasRCPmemb = true
        }
        members[len(members)] = memb
        // registerType(&fileDeps, memb.type, elems)
        membDeclStr str
        cmt = string(memb.type)
        if cmt.hasPrefix("function(") == 1 {
            membDeclStr = getCfunctionType(&cmt, memb.name, elems)
        } else if cmt.hasPrefix("buffer:") {
            membDeclStr = "char "+memb.name+"["+memb.type[7:]+"]"
        } else {
            membDecl = getCType(memb.type, elems)
            membDecl.append(" " + memb.name)
            membDeclStr = membDecl.str()
        }
        allMembs[len(allMembs)] = membDeclStr
        i++
    }
    s.members = members
    if doesOutput == true {
        OUTPUT = OOUT
        NEXT_LINE = nextLine
        code = rope("struct "+s.name+" {\n")

        if RCPavailable() {
            code += rope("volatile char __RCP_GUARD;\n")
        }

        i=0; for i < len(allMembs) {
            m = allMembs[i]
            code += rope(m +";\n")
            i++
        }
        code += rope("};\n")
        OUTPUT += code + bottomDecl
        phd = postDeclHandle.toStr()
        ropeSet(postDeclHandle, "")
        OUTPUT += rope(phd)
    }

    if debug == true {

        ds = new debugStruct
        ds.name = s.name
        i=0; for i < len(s.members) {
            m = s.members[i]
            mv = new debugVar
            mv.fromVar(<variable*>m)
            ds.membs[i] = mv
            i++
        }

        i=0; for i < len(s.methods), i++ {
            me = s.methods[i]
            ds.methods[i] = me.name
        }
        debugPrint("struct_declare", nameToken.line, ds)
    }


}

//Parses #define (for c bindings and forward functions declarations).
parseDefine(l []Tok, elems Elems*) {

    if len(l) < 3 {
        throwErr(&l[len(l)-1], "Invalid usage of define, cannot end on {TOKEN}.")
    }

    ft = l[1]
    st = l[2]

    i = 1
    doesOutput = true
    if ft.cont == "!" {
        ft = l[2]
        st = l[3]
        i = 2
        doesOutput = false
    }

    if st.cont == "(" {

        fn = new func
        header = parseFnHeader("", l, &i, fn, false, elems)
        code = header[1] + header[0]
        ofn = searchFunc(fn.name, elems, false)
        if ofn != null {
            throwWarningLine("Re-declaration of function "+ofn.name+"."+"\n\tPrevious declaration: "+ofn.file+":"+intToStr(ofn.line), ft.line)
        }
        fn.isBinding = true
        fn.isCbinding = doesOutput == false
        fn.file = compilerState.currentFile
        fn.line = ft.line
        elems.fns[len(elems.fns)] = fn
        if doesOutput == true {
            OUTPUT += rope(code+";\n")
        }

    } else {
        tp = ""
        i++; for i < len(l), i++ {
            t = l[i]
            tp += t.cont
        }
        if ft.type != TOKEN_TYPE_VAR {
            throwErr(&ft, "Cannot use {TOKEN} as new type name.")
        }
        cTypeNewType = getCType(tp, elems)
        cTypeNewTypeStr = cTypeNewType.str()
        if doesOutput == true {
            OUTPUT += rope("typedef " + cTypeNewTypeStr + " " + ft.cont + ";\n")
        }

        if debug == true {
            dt = new debugType
            dt.name = ft.cont
            dt.refers = tp
            debugPrint("type_declare", ft.line, dt)
        }

        tps = elems.types
        tps[len(tps)] = ft.cont
    }

}

//Parses #cLib (for including c libraries/setting c flags).
parseClib(line []Tok) {

    clibs = compilerState.cLibs

    i=1; for i < len(line) {
        t = line[i]
        if t.type != TOKEN_TYPE_STR {
            throwErr(&t, "Cannot use {TOKEN} as C library name.")
        }

        cc = string(t.cont)
        cc.trimLeft(1)
        cc.trimRight(1)
        ccstr = cc.str()

        found = false
        j=0; for j < len(clibs) {
            l = clibs[j]
            if l == ccstr {
                found = true
                break
            }
            j++
        }
        if found == true {
            i++
            continue
        }
        clibs[len(clibs)] = ccstr

        i++
    }

}

//Parses const declaration.
parseConst(l []Tok, elems Elems*) {
    l = parseCast(l, elems, true)
    if len(l) != 4 {
        throwErr(&l[0], "Invalid usage of {TOKEN}, must be 'const <constName> = <constValue>'. ")
    }
    vart = l[1]
    equt = l[2]
    valt = l[3]
    if vart.type != TOKEN_TYPE_VAR {
        throwErr(&vart, "Cannot take {TOKEN} as const name.")
    }
    if equt.cont != "=" {
        throwErr(&equt, "Expected '=' not {TOKEN}.")
    }
    if valt.isValue == false {
        throwErr(&equt, "Must be a value, not {TOKEN}.")
    }

    if valt.type == TOKEN_TYPE_VAR {
        fn = searchFunc(valt.cont, elems, true)
        if fn != null {
            fn.used = true
        }
    }

    v = new variable

    if isGlobal() {
        v.isGlobal = true
    }

    v.isConst = true
    v.constVal = valt.cont
    v.name = vart.cont
    v.type = getTypeFromToken(&valt, true, elems)
    vars = elems.vars
    vars[len(vars)] = v

    if valt.type == TOKEN_TYPE_STR {
        valt.cont = strLitteralToBahStr(valt.cont)
    }

    OUTPUT += rope("#define "+v.name+" "+valt.cont+"\n")

}

//Parses return.
parseReturn(l []Tok, elems Elems*) {
    if len(l) > 2 {
        throwErr(&l[2], "Invalid usage of return, must be 'return <returnValue>'. {TOKEN} not expected.")
    }
    if currentFn == null {
        throwErr(&l[0], "Cannot return a value outside of a function.")
    }
    rv = ""
    tt = ""
    tmpV variable* = null
    rvt Tok
    if len(l) == 1 {
        if len(currentFn.returns.type) != 0 {
            throwErr(&l[0], "Cannot return nothing as "+currentFn.returns.type+".")
        }
    } else {
        rvt = l[1]
        tt = getTypeFromToken(&rvt, true, elems)
        rv = rvt.cont
        if rvt.type == TOKEN_TYPE_VAR && rvt.isOper == false {
            tmpV = searchVirtVarByToken(&rvt, compilerState.currFnElems)
            if tmpV == null {
                tmpV = searchVirtVarByToken(&rvt, elems)
            }
            if tmpV != null && rvt.isOper == false {
                if isUnsafe == false && string(compilerState.currentDir).hasPrefix(BAH_DIR) == false && currentFn.returns.type[len(currentFn.returns.type)-1] != '!' {
                    if tmpV.canBeNull == true || rv == "null" {
                        currentFn.returns.canBeNull = true
                    }
                }
            }
        }
        if compTypes(tt, currentFn.returns.type) == false {
            throwErr(&rvt, "Cannot return {TOKEN} ("+tt+") as "+currentFn.returns.type+".")
        }
    }
    if compilerState.isBranch == false {
        currentFn.returned = true
    } else {
        currentFn.couldAlreadyReturn = true
        setNullStateBranchFlowEnd(elems)
    }

    fixMeEndScope(elems, &l[0])
    if len(rv) > 0 {
        rvar = rv
        stt = string(tt)
        if stt.hasPrefix("buffer:") {
            rvar = "buffToStr("+rvar+")"
        } else if stt.hasPrefix("[") && stt.hasSuffix("]") {
            size = getTupleSize(stt.str(), elems)
            OUTPUT += rope("memcpy(__BAH_TUPLE_RET_PTR, "+rv+", "+size+");\n")
            rvar = "__BAH_TUPLE_RET_PTR"
        }
        if RCPavailable() {
            retVal = genCompilerVar()
            OUTPUT += rope(getCType(currentFn.returns.type, elems).str()+" "+retVal+" = "+rvar+";\n")
            if isRCPtype(currentFn.returns.type, elems) && (rvt.isFunc == false || (rvt.isFunc && rvt.isOper))  {
                RCPincrVar(retVal, isRCPpointerType(currentFn.returns.type))
            }
            RCPendScopeRange(elems, compilerState.currFnElems)
            OUTPUT += rope("return "+retVal+";\n")

        } else {
            OUTPUT += rope("return "+rvar+";\n")
        }
    } else {
        RCPendScopeRange(elems, compilerState.currFnElems)
        OUTPUT += rope("return;\n")
    }
}

//Parses if block.
parseIf(l []Tok, fromElse bool, elems Elems*) {
    prevIfExits = false
        ft = l[0]
    if len(l) < 4 {
        throwErr(&ft, "Invalid usage of {TOKEN}, must be 'if <condition> {<code>}'")
    }
    condt = l[1]
    tt = getTypeFromToken(&condt, true, elems)
    if compTypes(tt, "bool") == false {
        throwErr(&condt, "Cannot use {TOKEN} as condition in if statement.")
    }

    t = l[2]
    if t.cont != "{" {
        throwErr(&t, "Expected '{' not {TOKEN} after condtition in if statement.")
    }
    tokens = l[3:len(l)-1]

    begIfHandle = rope("")
    OUTPUT += begIfHandle


    ifHeader = rope("if ("+prevIfShortcut+condt.cont+") {\n")

    OUTPUT += ifHeader

    ifElems = elems
    if fromElse == false {

        //Initialize optimazation to replace by C switch
        if condt.switchOpt != null {
            elems.switchOpt = new chainsToSwitch {
                var: condt.switchOpt.var
            }
            elems.switchOpt.values[0] = condt.switchOpt.value
            elems.switchOpt.headerRopes[0] = ifHeader
        }

        ifElems = dupElems(elems)
    }


    if fromElse == true {
        if elems.switchOpt != null {
            if condt.switchOpt == null {
                elems.resetSwitchOpt()
            } else {
                if (<Tok*>condt.switchOpt.var).cont != (<Tok*>elems.switchOpt.var).cont {
                    elems.resetSwitchOpt()
                } else {
                    elems.switchOpt.values[len(elems.switchOpt.values)] = condt.switchOpt.value
                    elems.switchOpt.headerRopes[len(elems.switchOpt.headerRopes)] = ifHeader

                }
            }
        }

        i=0; for i < len(prevIfChecks), i++ {
            bc = prevIfChecks[i]
            bc.checkNull = bc.checkNull == false
            ifElems.branchChecks[i] = bc
        }
    }

    i=0; for i < len(currChecks), i++ {
        ifElems.branchChecks[len(ifElems.branchChecks)] = currChecks[i]
    }
    prevIfChecks = ifElems.branchChecks

    oldIB = compilerState.isBranch
    compilerState.isBranch = true

    oifeso = ifElems.switchOpt
    ifElems.switchOpt = null

    parseLines(tokens, ifElems)

    ifElems.switchOpt = oifeso

    RCPendScope(ifElems)


    if ifElems.currFlowEnd == true {
        OUTPUT.totalLen += ropeSet(ifHeader, "if (__builtin_expect("+condt.cont+", 0)) {\n")
        // println("branch exits: "+compilerState.currentFile+":"+intToStr(ft.line))
    }

    fixMeEndScope(ifElems, &tokens[len(tokens)-1])
    if debug == true {
        lt = l[len(l)-1]
        debugEndScope(lt.line, ifElems)
    }
    compilerState.isBranch = oldIB

    cb = rope("}\n")
    OUTPUT += cb

    if elems.switchOpt != null {
        elems.switchOpt.footerRopes[len(elems.switchOpt.footerRopes)] = cb
    }


    prevIfShortcut = ""
}

//Parses else block.
parseElse(l []Tok, elems Elems*) {

    if prevLine != LINE_TYPE_IF && prevLine != LINE_TYPE_ELSE {
        throwErr(&l[0], "Can only use {TOKEN} after 'if' statement.")
    }
    if len(l) < 3 {
        throwErr(&l[0], "Incalid usage of {TOKEN}, must be 'else {<code>}'.")
    }
    ft = l[1]

    prevReturned = prevIfExits

    if ft.cont == "if" {
        memory = []Tok
        i=1; for i < len(l) {
            memory[len(memory)] = l[i]
            i++
        }
        parseIf(memory, true, elems)
        prevLine = LINE_TYPE_IF
    } else {
        if ft.cont != "{" {
            throwErr(&ft, "Expected 'if' or '{' not {TOKEN}.")
        }
        memory = []Tok
        max = len(l) - 1
        i=2; for i < max {
            memory[len(memory)] = l[i]
            i++
        }

        i=0; for i < len(prevIfChecks), i++ {
            bc = prevIfChecks[i]
            bc.checkNull = bc.checkNull == false
            elems.branchChecks[i] = bc
        }

        oldIB = compilerState.isBranch
        compilerState.isBranch = true
        t = l[0]
        if len(memory) == 0 {
            throwWarningLine("Empty else block.", t.line)
        } else {
            oswtopt = elems.switchOpt
            elems.switchOpt = null
            parseLines(memory, elems)
            elems.switchOpt = oswtopt
        }
        RCPendScope(elems)
        fixMeEndScope(elems, &memory[len(memory)-1])
        if debug == true {
            lt = l[len(l)-1]
            debugEndScope(lt.line, elems)
        }
        compilerState.isBranch = oldIB
        prevIfExits = false
    }

}

//Parses for block.
parseFor(l []Tok, elems Elems*) {

    if len(l) < 4 {
        throwErr(&l[0], "Invalid usage of {TOKEN}.")
    }

    nbComas = 0
    i=1; for i < len(l) {
        t = l[i]
        if t.cont == "{" {
            break
        }
        if t.type == TOKEN_TYPE_SYNTAX && t.cont == "," {
            if nbComas == 1 {
                throwErr(&t, "Invalid line separation of for, cannot set more than 2 lines: {TOKEN}.")
            }
            nbComas++
        }
        i++
    }

    ifElems = dupElems(elems)
    tokens = []Tok
    condt = l[1]
    if compTypes(getTypeFromToken(&condt, true, elems), "bool") == false {
        throwErr(&condt, "Cannot use {TOKEN} as condition in for statement.")
    }

    if nbComas > 0 {
        if nbComas != 1 {
            t = l[0]
            throwErr(&t, "Invalid usage of {TOKEN}, can only partition line in 2 using 'for <condition>, <insctruction> {<code>}'.")
        }

        inst = []Tok


        st = l[2]

        if st.type != TOKEN_TYPE_SYNTAX || st.cont != "," {
            throwErr(&st, "Cannot use {TOKEN}, need ',' to split for loop instructions.")
        }

        i=3; for i < len(l), i++ {
            t = l[i]
            if t.type == TOKEN_TYPE_ENCL && t.cont == "{" {
                break
            }
            inst[len(inst)] = t
        }

        oldOut = OUTPUT
        OUTPUT = rope("")

        inst = prePross(inst, LINE_TYPE_ELSE, ifElems)
        parseVar(inst, ifElems)

        instC = string(OUTPUT.toStr())
        OUTPUT = oldOut
        instC.trimRight(2)

        t = l[i]
        if t.cont != "{" {
            throwErr(&t, "Expected '{' not {TOKEN} after '<condition>,<instruction>' in for statement.")
        }

        max = len(l) - 1
        i++;for i < max, i++ {
            t = l[i]
            tokens[len(tokens)] = t
        }

        OUTPUT += rope("for (; "+condt.cont+"; "+instC.str()+") {\n")

    } else {
        t = l[2]
        if t.cont != "{" {
            throwErr(&t, "Expected '{' not {TOKEN} after condtition in for statement.")
        }
        max = len(l) - 1
        i=3;for i < max, i++ {
            t = l[i]
            tokens[len(tokens)] = t
        }
        OUTPUT += rope("while ("+condt.cont+") {\n")
    }
    oForElems = compilerState.currForElems
    compilerState.currForElems = ifElems

    oldIB = compilerState.isBranch
    oldIF = compilerState.isFor
    compilerState.isBranch = true
    compilerState.isFor = true
    t = l[0]
    ifElems.switchOptCurrLoop = genCompilerVar()
    parseLines(tokens, ifElems)
    RCPendScope(ifElems)
    fixMeEndScope(ifElems, &tokens[len(tokens)-1])

    if isUnsafe == false {
        i=0; for i < len(ifElems.vars), i++ {
            v = ifElems.vars[i]
            if v.iterScope == elems {
                if v.lastSet != ifElems && ifElems.isChildren(v.lastSet) == false {
                    throwWarningLine("For loop iterates over variable '"+v.name+"' but its value is not changed inside the scope of the for loop.
    This may result in the loop never terminating.", t.line)
                }
                v.iterScope = null
            }
        }
    }

    if debug == true {
        lt = l[len(l)-1]
        debugEndScope(lt.line, ifElems)
    }
    compilerState.isFor = oldIF
    compilerState.isBranch = oldIB
    compilerState.currForElems = oForElems
    OUTPUT += rope("};\n"+ifElems.switchOptCurrLoop+": ;\n")

}

//Parses continue/break statements.
parseForOp(l []Tok, elems Elems*) {

    ft = l[0]
    if compilerState.isFor == false {
        throwErr(&ft, "Cannot {TOKEN} outside of for statement.")
    }
    if len(l) != 1 {
        throwErr(&ft, "Nothing expected after {TOKEN}.")
    }
    //TODO: include outter forloop declared variables incase the keyword is inside a if branch,etc...

    RCPendScope(elems)
    RCPendScope(compilerState.currForElems)
    fixMeEndScope(elems, &ft)
    fixMeEndScope(compilerState.currForElems, &ft)

    if ft.cont == "break" {
        OUTPUT += rope("goto "+elems.switchOptCurrLoop+";\n")
    } else {
        OUTPUT += rope(ft.cont + ";\n")
    }


}

//Used for generating C wrapper for function evaluation.
makeEvalFunc(fn func*, elems Elems*) {
    if fn.name in compilerState.evals {
        return
    }

    efn = new func{
        name: "__Bah_eval_"+fn.name
    }
    efn.returns = new variable {
        type: "ptr"
    }

    efn.args = []variable*{
        new variable{
            name: "fnArgs"
            type: "[]ptr"
        }
    }

    fnBinding = ""
    fnCall = fn.name+"("
    i=0; for i < len(fn.args), i++ {
        a = fn.args[i]
        v = genCompilerVar()
        cType = getCType(a.type, elems)
        if isRCPpointerType(a.type) == false {
            cType.append("*")
        }
        fnBinding += cType.str() + " " + v + " = (("+cType.str()+"*)fnArgs->data)[" + intToStr(i) + "];"
        if i != 0 {
            fnCall += ", "
        }
        if isRCPpointerType(a.type) {
            fnCall += v
        } else {
            fnCall += "*"+v
        }
    }

    setReturnValue = "void* r = 0;"
    if isRCPpointerType(fn.returns.type) {
        setReturnValue = "void* r = "
    } else {
        cType = getCType(fn.returns.type, elems)
        if cType.str() != "void" {
            setReturnValue = cType.str()+"* r = memoryAlloc(sizeof("+cType.str()+"));*r = "
        }
    }

    cleanup = ""

    if RCPavailable() {
        cleanup = RCPdecrVarStr("fnArgs", true)
    }

    OUTPUT += rope("void* __attribute__((optimize(\"O0\"))) "+efn.name+"(struct Bah_Array_Type* fnArgs) {
        if (fnArgs->length != "+uintToStr(len(fn.args))+") {
            __BAH_panic((char*)"+strLitteralToBahStr("\"eval: calling function "+fn.name+"() with the wrong number of arguments.\"")+", "+strLitteralToBahStr("\"BAH_COMPILER_INTERNAL\"")+");
        }
        "+fnBinding+"
        "+setReturnValue+fnCall+");
        "+cleanup+"
        return (void*)r;
    };")

    compilerState.evals[len(compilerState.evals)] = fn.name
    elems.fns[len(elems.fns)] = efn
}

//Parses #linux,#dynamic... block.
parsePreKeyword(l []Tok, elems Elems*) {

    ft = l[0]

    if ft.cont == "#warning" {
        if len(l) != 2 {
            throwErr(&ft, "Invalid usage of {TOKEN} '#warning \"message\"'.")
        }
        mt = l[1]
        if mt.type != TOKEN_TYPE_STR {
            throwErr(&mt, "Cannot use {TOKEN} as a string.")
        }

        msg = string(mt.cont)
        msg.trimLeft(1)
        msg.trimRight(1)


        throwWarning(msg.str())
        return
    }


    if ft.cont == "#eval" {

        if "eval.bah" in compilerState.includes == false {
            if includeFile("eval.bah", elems) == false {
                throwErr(&l[0], "Could not find file 'eval.bah'. Check your bah directory ("+BAH_DIR+").")
            }
        }

        if len(l) != 2 || isGlobal() == false {
            throwErr(&l[0], "Invalid usage of {TOKEN} <#eval fnName>.")
        }

        fnT = l[1]
        fn = searchFunc(fnT.cont, elems, false)
        if fn == null {
            throwErr(&fnT, "Unknown function {TOKEN}.")
        }
        fn.used = true

        makeEvalFunc(fn, elems)

        return
    }

    if ft.cont == "#evalAll" {
        i=0; for i < len(elems.fns), i++ {
            fn = elems.fns[i]
            fn.used = true
            if fn.isBinding == false && strHasPrefix(fn.name, "__Bah_eval_") == false {
                makeEvalFunc(fn, elems)
            }
        }
        return
    }

    if len(l) < 3 {
        throwErr(&ft, "Invalid usage of keyword {TOKEN}.")
    }

    if ft.cont == "#linux" || ft.cont == "#windows" || ft.cont == "#darwin" {
        isOS = string(ft.cont)
        isOS.trimLeft(1)
        if isOS.str() != BAH_OS {
            return
        }
    } else if ft.cont == "#static" {
        if flags.isSet("d") == 1 {
            return
        }
    } else if ft.cont == "#dynamic" {
        if flags.isSet("d") == 0 {
            return
        }
    } else if ft.cont == "#gc" {
        if RCPavailable() == true || lightGCenabled || nativeMemenabled {
            return
        }
    } else if ft.cont == "#altMem" {
        if lightGCenabled == false && nativeMemenabled == false {
            return
        }
    } else if ft.cont == "#rcp" {
        if RCPavailable() == false {
            return
        }
    } else if ft.cont == "#lib" {
        if flags.isSet("l") == 0 {
            return
        }
    } else if ft.cont == "#exec" {
        if flags.isSet("l") == 1 {
            return
        }
    } else if ft.cont == "#imported" {
        if isSubObject == false || isObject == false {
            return
        }
    } else if ft.cont == "#main" {
        if isSubObject == true || isObject == true {
            return
        }
    } else if ft.cont == "#included" {
        if isSubObject == true || isObject == true {
            return
        }
    } else if ft.cont == "#optimized" {
        if isOptimized == false {
            return
        }
    } else if ft.cont == "#unoptimized" {
        if isOptimized == true {
            return
        }
    } else {
        throwErr(&ft, "Undefined token {TOKEN}.")
    }

    st = l[1]
    lt = l[len(l)-1]
    if st.cont != "{" || lt.cont != "}" {
        throwErr(&st, "Expected code block after keyword {TOKEN}.")
    }

    nl = []Tok
    i=2; for i < len(l) - 1 {
        nl[i-2] = l[i]
        i++
    }

    parseLines(nl, elems)

}

//Parses async function call.
parseAsync(l []Tok, elems Elems*) {
    if len(l) != 2 {
        ft = l[0]
        throwErr(&ft, "Cannot use keyword {TOKEN} on a function call 'async <function call>'.")
    }
    fnT = l[1]
    if fnT.isFunc == false {
        throwErr(&fnT, "Cannot use keyword async on {TOKEN}. Usage: 'async <function call>'.")
    }

    found = false
    i=0; for i < len(compilerState.cLibs) {
        if compilerState.cLibs[i] == "lpthread" {
            found = true
            break
        }
        i++
    }
    if found == false {
        compilerState.cLibs[len(compilerState.cLibs)] = "lpthread"
    }

    sFnT = string(fnT.cont)

    fnNameParts = splitString(sFnT, "(")
    fnName = fnNameParts[0]

    fn = searchVirtFuncByToken(&fnT, elems)

    if fn == null {
        throwErr(&fnT, "Internal compiler error.\n Error parsing async call for function '"+fnName.str()+"', arround {TOKEN}.")
    }
    fnName = string(fn.name)
    sMembs = ""
    unSerMembs = ""
    threadClean = ""
    threadPrep = ""

    i=0; for i < len(fn.args), i++ {
        a = fn.args[i]
        cType = getCType(a.type, elems)
        sMembs += cType.str()+" "+a.name+";\n"
        unSerMembs += "args->"+a.name
        if RCPavailable() && isRCPtype(a.type, elems) {
            threadPrep  += RCPincrVarStr("args->"+a.name, isRCPpointerType(a.type))
            threadClean += RCPdecrVarStr("args->"+a.name, isRCPpointerType(a.type))
        }
        if i+1 < len(fn.args) {
            unSerMembs += ", "
        }
    }

    // Fixes 'async struct.function()' when function is not a method but a member and need its symbol
    // to be created is the new thread wrapper's scope
    if fn.isVar && fn.fromVar != null {
        threadPrep += getCType(fn.fromVar.type, elems).str() + " " + fn.fromVar.name + " = args->" + fn.args[0].name + ";"
    }


    if RCPavailable() {
        threadClean += "RCP_decr(args, sizeof(*args));\n"
    }

    tmpArgsStruct = "struct {\n"+sMembs+"}"
    fnWrapper = genCompilerVar()
    tmpArgs = genCompilerVar()

    sFnT.trimLeft(fnName.length+1)
    sFnT.trimRight(1)

    OUTPUT.totalLen += ropeSet(postDeclHandle, postDeclHandle.toStr() + "
    void "+fnWrapper+"("+tmpArgsStruct+"* args) {
        "+threadPrep+"
        "+fnName.str()+"("+unSerMembs+");
        "+threadClean+"
    };\n")

    OUTPUT += rope(
    "{
        "+tmpArgsStruct+" "+tmpArgs+" = {"+sFnT.str()+"};
        void* tmpArgs = memoryAlloc(sizeof("+tmpArgs+"));
        memcpy(tmpArgs, &"+tmpArgs+", sizeof("+tmpArgs+"));
        pthread_t id;
        pthread_attr_t attr;
        pthread_attr_init(&attr);
        pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
        __thread_create(&id, &attr, "+fnWrapper+", tmpArgs);
        pthread_attr_destroy(&attr);
    };

    ")
}

//Parse chan declaration.
parseChan(l []Tok, elems Elems*) []Tok {
    nl = []Tok
    i=0; for i < len(l), i++ {
        t = l[i]
        if t.type == TOKEN_TYPE_SYNTAX && t.cont == "->" || t.cont == "<-" {
            //receive
            if t.cont == "<-" {
                i++
                if i < len(l) {
                    nt = l[i]
                    if nt.type != TOKEN_TYPE_VAR {
                        throwErr(&nt, "Cannot use {TOKEN} as channel.")
                    }
                    ntt = string(getTypeFromToken(&nt, true, elems))
                    if ntt.hasPrefix("chan:") == 0 {
                        throwErr(&nt, "Cannot use var {TOKEN} ("+ntt.str()+") as channel.")
                    }
                    ntt.trimLeft(5)

                    if isGlobal() {
                        throwErr(&t, "Cannot receive ({TOKEN}) from a channel outside of a function.")
                    }

                    tmpV = ""

                    if isRCPpointerType(ntt.str()) {
                        ct = getCType(ntt.str(), elems)
                        t.cont = "("+ct.str()+")"+nt.cont+"->receive("+nt.cont+")"
                    } else {
                        ct = getCType(ntt.str(), elems)
                        t.cont = "*("+ct.str()+"*)"+nt.cont+"->receive("+nt.cont+")"
                    }
                    t.type = TOKEN_TYPE_FUNC
                    t.isFunc = true

                    t.isValue = true
                    t.bahType = ntt.str()
                } else {
                    throwErr(&t, "Cannot use {TOKEN} on nothing")
                }
            } else { //send
                if i == 0 {
                    throwErr(&t, "Cannot une {TOKEN} on nothing.")
                }
                if i+1 >= len(l) {
                    throwErr(&t, "Cannot send ({TOKEN}) to nothing.")
                }
                pt = l[i+1]
                nt = l[i-1]
                ntt = getTypeFromToken(&nt, true, elems)

                if pt.type != TOKEN_TYPE_VAR {
                    throwErr(&pt, "Cannot use {TOKEN} as channel.")
                }
                ptt = string(getTypeFromToken(&pt, true, elems))
                if ptt.hasPrefix("chan:") == 0 {
                    throwErr(&pt, "Cannot use var {TOKEN} ("+ntt+") as channel.")
                }
                ptt.trimLeft(5)

                if isGlobal() {
                    throwErr(&t, "Cannot send ({TOKEN}) to a channel outside of a function.")
                }

                if compTypes(ptt.str(), ntt) == false {
                    throwErr(&nt, "Cannot send {TOKEN} ("+ntt+") to channel of type "+ptt.str()+".")
                }

                i++
                if isRCPpointerType(ptt.str()) {
                    OUTPUT += rope(pt.cont+"->send("+pt.cont+", "+nt.cont+");\n")
                } else {
                    ct = getCType(ntt, elems)
                    tmpV = genCompilerVar()
                    OUTPUT += rope("
                    "+ct.str()+" "+tmpV+" = "+nt.cont+";
                    "+pt.cont+"->sendAny("+pt.cont+", &"+tmpV+", sizeof("+tmpV+"));\n")
                }

                nl = []Tok
                return nl
            }
        }
        nl[len(nl)] = t
    }
    return nl
}

#include "values.bah" //for handling values

//Used for reducing lines to ireducible tokens (parsing values and such).
prePross(line []Tok, ltp lineType, elems Elems*) []Tok {
    fl = <[]Tok>null
    i = 0
    sepI = 0
    nbPar = 0
    flEnd = 0

    if ltp != <lineType>-1 {
        for i < len(line), i++ {
            t = line[i]
            if t.type == TOKEN_TYPE_ENCL {
                if t.cont[0] == '(' {
                    isFunc = true
                    nbPar++
                } else if t.cont[0] == ')' {
                    nbPar--
                } else if nbPar == 0 && t.cont[0] == '{' && (i == 0 || line[i-1].cont != "=>") {
                    if line[i+1].line != t.line {
                        break
                    }
                }
            }
        }
        if i != len(line) {
            fl = line[:i]
        } else {
            fl = line
        }
        sepI = i
    } else {
        fl = line
    }

    pt = Tok{}
    l = len(fl)

    i=0; for i < len(fl), i++ {
        t = fl[i]
        if t.type == TOKEN_TYPE_VAR && t.isOper == false && t.cont[0] == '&' {
            tc = string(t.cont)
            tc.trimLeft(1)
            rv = getRealVar(tc.str(), elems)
            if rv != null && rv.canBeReg == true && rv.declRope != null {
                rvdr = rv.declRope.toStr()
                if strHasPrefix(rvdr, "register ") {
                    rvdr = rvdr[9:]
                    OUTPUT.totalLen += ropeSet(rv.declRope, rvdr)
                }
                rv.canBeReg = false
            }
        } else if fl[i].type == TOKEN_TYPE_STR && fl[i].processedStr == false {
            fl[i].cont = strLitteralToBahStr(fl[i].cont)
            fl[i].processedStr = true
        }
    }

    if fixMeEnabled() {
        i=0; for i < len(fl), i++ {
            if fl[i].cont[0] == '*' {
                fixMeTestVar(&fl[i], ltp, elems)
            }
        }
    }

    i=0; for i < len(fl), i++ {
        t = fl[i]
        if i > 0 {
            pt = fl[i-1]
        } else {
            pt = Tok{}
        }
        //parse struct values
        if t.hasAmp && isValue(fl, i) && t.processedPtr == false {
            t.processedPtr = true
            if t.getRefVar() == null {
                let v = searchVar(t.cont, &t, elems) then {
                    if isRCPtype(v.type, elems) {
                        tmpName = "keep_ref_"+genCompilerVar()
                        elems.vars[len(elems.vars)] = new variable {
                            name: tmpName
                            type: v.type
                            declScope: elems
                        }
                        OUTPUT += rope(getCType(v.type, elems).str()+" "+tmpName+" = "+v.name[1:]+";\n")
                    }
                    v.type += "*"
                    t.setRefVar(v)
                }
                if t.bahType == "" {
                    t.bahType = getTypeFromToken(&t, true, elems)
                    if t.bahType[0] == '[' && t.bahType[len(t.bahType)-1] == ']' {
                        throwErr(&t, "Cannot get the pointer of a tuple {TOKEN}.")
                    } else if strHasPrefix(t.bahType, "[]") {
                        throwErr(&t, "Cannot get the pointer of an array {TOKEN} (it already is). Try casting it to a ptr to proceed.")
                    }
                }
                t.bahType += "*"
            }
            fl[i] = t
            i -= 1
        } else if t.cont == "." && i > 0 {
            i = valueStruct(fl, i, ltp, elems) - 1
        } else if t.cont == "(" && pt.cont != "function" {
            i = valueFunc(null, null, fl, i, ltp, elems) - 1
        } else if t.cont == "[" && pt.isValue == true {
            i = valueArr(fl, i, ltp, elems) - 1
        } else if t.cont == "[" {
            i = valueTuple(fl, i, elems) - 1
        } else if pt.type == TOKEN_TYPE_CAST && isSmallValue(fl, i) {
            delete(fl, i-1)
            ptc = string(pt.cont)
            ptc.trimLeft(1)
            ptc.trimRight(1)
            if t.type == TOKEN_TYPE_VAR {
                let v = searchVirtVarByToken(&t, elems) then {
                    t.setRefVar(v)
                }
            }
            t.bahType = ptc.str()
            cType = getCType(ptc.str(), elems)
            t.cont = "("+cType.str()+")"+t.cont
            fl[i-1] = t
            i -= 2
        } else if pt.type == TOKEN_TYPE_SYNTAX && pt.cont in signs && i > 1 {
            if t.cont == pt.cont {
                ppt = fl[i-2]
                if ppt.type == TOKEN_TYPE_VAR {
                    posTok = i-2
                    deleteRange(fl, i-1, i)
                    if ppt.getRefVar() == null {
                        let v = searchVirtVarByToken(&ppt, elems) then {
                            ppt.setRefVar(v)
                        }
                    }

                    ppt.cont = t.cont + t.cont + ppt.cont
                    ppt.isValue = true
                    ppt.isOper = true
                    fl[posTok] = ppt
                    i = posTok-1
                } else {
                    throwErr(&ppt, "Cannot increment/decrement non variable value {TOKEN}.")
                }
            } else if isValue(fl, i) {
                i = valueOper(fl, i, elems) - 1
            }
        } else if t.cont[0] == '-' && pt.isValue == true {
            if t.type == TOKEN_TYPE_INT || t.type == TOKEN_TYPE_FLOAT {
                delete(fl, i)
                ptt = getTypeFromToken(&pt, true, elems)
                pt.bahType = ptt
                pt.isOper = true
                pt.cont += t.cont
                fl[i-1] = pt
                i -= 2
            }
        } else if ((pt.type == TOKEN_TYPE_SYNTAX && pt.cont in comparators) || pt.cont == "in") && isValue(fl, i) {
            i = valueBool(fl, i, ltp, elems) - 1
        } else if pt.cont == "<-" && isValue(fl, i) {
            i = valueChan(fl, i, elems) - 1
        } else if pt.cont == "->" && isValue(fl, i) {
            if i-2 >= 0 {
                if isValue(fl, i-2) {
                    i = valueSendChan(fl, i, elems) - 1
                }
            } else {
                throwErr(&t, "Cannot {TOKEN} nothing through chan.")
            }
        }
    }


    i=0; for i < len(fl), i++ {
        t = fl[i]
        if t.type == TOKEN_TYPE_SYNTAX && (t.cont == "||" || t.cont == "&&") {
            if i == 0 || i+1 == len(fl) {
                throwErr(&t, "Cannot use {TOKEN} on nothing.")
            }
            pt = fl[i-1]
            nt = fl[i+1]
            ptt = getTypeFromToken(&pt, true, elems)
            ntt = getTypeFromToken(&nt, true, elems)
            if compTypes(ptt, ntt) == false || compTypes(ptt, "bool") == false {
                throwErr(&t, "Cannot use {TOKEN} on "+ptt+".")
            }
            pt.cont += t.cont + nt.cont

            //Remove switchable property
            pt.switchOpt = null

            fl[i-1] = pt
            deleteRange(fl, i, i+1)
            i -= 2
        }
    }

    if ltp != <lineType>-1 {
        if sepI == len(fl) {
            i=0; for i < sepI, i++ {
                line[i] = fl[i]
            }
            fl = line
        } else {
            for sepI < len(line) {
                fl[len(fl)] = line[sepI]
                sepI++
            }
        }
    }



    return fl
}

//Parses function declaration.
parseFnDeclare(l []Tok, elems Elems*) {
    i = 0
    fn = new func

    if RCPavailable() == false && RCPenabled == true { //currently parsing a rcp file
        fn.used = true
    }

    ft = l[0]
    header = parseFnHeader("", l, &i, fn, false, elems)
    code = header[1] + header[0]
    fn.line = ft.line
    fn.file = compilerState.currentFile
    ogFn = searchFunc(fn.name, elems, false)
    if ogFn != null {
        if ogFn.isBinding == false {
            lineStr = intToStr(ogFn.line)
            throwErr(&ft, "Cannot redeclare function {TOKEN}, previous declaration: "+ogFn.file+":"+lineStr+".")
        }
    }

    if fn.name == "main" {
        compilerState.haveEntryPoint = true
        if compTypes(fn.returns.type, "int") == false {
            throwErr(&ft, "{TOKEN} function should return 'int'.")
        }
        if len(fn.args) != 1 {
            throwErr(&ft, "{TOKEN} function should take one []str argument. Should be:
            'main(args []str) int'")
        }
        fa = fn.args[0]
        if compTypes(fa.type, "[]str") == false {
            throwErr(&ft, "{TOKEN} function should take []str as argument. Should be:
            'main(args []str) int'")
        }
    }

    if debug == true {
        df = new debugFunction
        df.name = fn.name
        j=0; for j < len(fn.args), j++ {
            dfa = new debugVar
            dfa.fromVar(fn.args[j])
            df.args[j] = dfa
        }
        df.returns = fn.returns.type
        debugPrint("fn_declare", ft.line, df)
    }

    j=0; for j < len(fn.args), j++ {
        if fn.args[j].type == "<any>" {
            generics[len(generics)] = new genericFunc {
                tokens: l[i+1:len(l)-1]
                baseFn: fn
                tokenName: &ft
                file: compilerState.currentFile
            }
            return
        }
    }

    if shouldOnlyDecl == true {
        if ogFn != null {
            fn.isBinding = false
        }
        fn.isImported = true
        elems.fns[len(elems.fns)] = fn
        OUTPUT += rope(code+";\n")
        return
    }

    postDeclHandle = rope("")
    OUTPUT += postDeclHandle

    code += "{\n"

    fn.code = rope(code)


    fnElems = dupElems(elems)

    vs = fnElems.vars
    j=0; for j < len(fn.args) {
        a = fn.args[j]
        a.declScope = elems
        a.isArg = true
        vs[len(vs)] = a
        j++
    }
    fnElems.vars = vs

    if ogFn != null {
        ogFn.isBinding = false
        ogFn.used = true
        ogFn = fn
    } else {
        fns = elems.fns
        fns[len(fns)] = fn
    }

    i++
    tokens = l[i:len(l)-1]

    if len(tokens) == 0 {
        fn.code += rope("};\n")
        OUTPUT += fn.code
        return
    }

    currentFn = fn

    oOut = OUTPUT
    OUTPUT = rope("")
    ocurrFnElems = compilerState.currFnElems
    compilerState.currFnElems = fnElems
    parseLines(tokens, fnElems)
    OPTI_checkFuncScopeRef(fnElems)
    RCPendScope(fnElems)

    compilerState.currFnElems = ocurrFnElems
    currentFn = null
    if fn.returned == false {
        if len(fn.returns.type) > 0 {
            throwErr(&l[len(l)-1], "Function '"+fn.name+"' is not returned.")
        }
        fixMeEndScope(fnElems, &tokens[len(tokens)-1])
        // decrRCPstackVars(fn.args, elems)
    }

    fn.code += OUTPUT
    OUTPUT = oOut
    fn.code += rope("};\n")

    if debug == true {
        lt = l[len(l)-1]
        debugEndScope(lt.line, fnElems)
    }

    OUTPUT += fn.code

}

//Parses let declaration and block handling.
//If an else block is used, it will be called if the value is null.
//The code block must break the execution flow (return/exit/panic...).
// let a = func() else {<code>}
//If a then block is used, it will be called if the value is not null.
//The declared variable will not continue to exist after the scope of the then block.
// let b = func() then {<code>}
parseLet(line []Tok, elems Elems*) {
    if len(line) < 7 {
        throwErr(&line[0], "Invalid usage of {TOKEN} 'let <var> = <maybe value> else|then {<code>}'")
    }

    varTok = line[1]
    valTok = line[3]
    isThen = false
    //check variable token
    if varTok.type != TOKEN_TYPE_VAR {
        throwErr(&varTok, "Cannot use {TOKEN} as variable.")
    }

    //check equal sign
    if line[2].cont != "=" {
        throwErr(&line[2], "Expected '=' got {TOKEN}.")
    }

    isMaybe = true
    newType = ""

    //check valTok
    valType = getTypeFromToken(&valTok, true, elems)
    if valType[len(valType)-1] != '!' {
        if isRCPpointerType(valType) == false {
            throwErr(&valTok, "Cannot use {TOKEN} ("+valType+") as maybe value / pointer.")
        }
        isMaybe = false
        newType = valType
    } else {
        newType = valType[:len(valType)-1]+"*"
    }

    //check else tok
    if line[4].cont != "else" && line[4].cont != "then" {
        throwErr(&line[4], "Expected 'then' or 'else' got {TOKEN}.")
    }

    if line[4].cont == "then" {
        isThen = true
    }

    tmpVar = ""

    //asign variable
    v = searchVarByToken(&varTok, elems)
    code = ""
    if v == null {
        v = new variable {
            name: varTok.cont
            type: newType
        }
        if isThen == false {
            elems.vars[len(elems.vars)] = v
            code = getCType(v.type, elems).str() + " " + v.name + " = " + valTok.cont+";"
        } else {
            tmpVar = genCompilerVar()
            code = getCType(v.type, elems).str() + " " + tmpVar + " = " + valTok.cont+";"
        }
    } else {
        if v.type != newType {
            throwErr(&varTok, "Cannot use var {TOKEN} ("+v.type+") as "+newType+".")
        }
    }

    v.canBeNull = isThen == false
    captElems = dupElems(elems)
    ocib = compilerState.isBranch
    compilerState.isBranch = true
    
    if isThen {
        v.declScope = captElems
    } else {
        v.declScope = elems
    }

    if isThen == true {
        code += "if ("+tmpVar+" != null) {\n"+getCType(v.type, elems).str() + " " + v.name + " = " + tmpVar+";\n"
        captElems.vars[len(captElems.vars)] = v
        elems.deletedVars[len(elems.deletedVars)] = v
    } else {
        code += "if ("+v.name+" == null) {"
    }

    OUTPUT += rope(code)

    tokens = line[6:len(line)-1]

    parseLines(tokens, captElems)
    RCPendScope(captElems)

    fixMeEndScope(captElems, &tokens[len(tokens)-1])
    if debug == true {
        lt = line[len(line)-1]
        debugEndScope(lt.line, captElems)
    }

    compilerState.isBranch = ocib


    if isThen == true {
        v.canBeNull = true
        OUTPUT += rope("}\n")
    } else {
        if isUnsafe == false && v.canBeNull == true && checkedNotNull(v.name, captElems) == false && captElems.currFlowEnd == false {
            throwErr(&line[0], "Variable "+v.name+" could still be null after exiting else block and program is not terminated")
        } else {
            v.canBeNull = false
        }
        OUTPUT += rope("}\n")
    }


}

// Checks done after parsing a line.
afterLineCheck(line []Tok, ltp lineType, elems Elems*) {

    // At the end of a else if chain
    if (prevLine == LINE_TYPE_IF || prevLine == LINE_TYPE_ELSE) && (ltp != LINE_TYPE_ELSE) && compilerState.nbElseIf > 0 {

        // try to optimize the chain into a C switch statement
        if elems.switchOpt != null && compilerState.nbElseIf > 3 {

            //First value is odd
            t Tok* = elems.switchOpt.values[0]
            v Tok* = elems.switchOpt.var
            OUTPUT.totalLen += ropeSet(elems.switchOpt.headerRopes[0], "switch("+v.cont+"){\ncase "+t.cont+":{\n")

            i=1; for i < len(elems.switchOpt.values), i++ {
                t = <Tok*>elems.switchOpt.values[i]
                OUTPUT.totalLen += ropeSet(elems.switchOpt.headerRopes[i*2], "case "+t.cont+": {\n")
                OUTPUT.totalLen += ropeSet(elems.switchOpt.headerRopes[(i*2)-1], "}break;\n")
            }

            //ends on a else {} statement (no value attached to a case)
            if len(elems.switchOpt.headerRopes) % 2 == 0 {
                OUTPUT.totalLen += ropeSet(elems.switchOpt.headerRopes[len(elems.switchOpt.headerRopes)-1], "default: {\n")
                i = 0; for i < len(elems.switchOpt.footerRopes)-1, i++ {
                    OUTPUT.totalLen += ropeSet(elems.switchOpt.footerRopes[i], "")
                }
                OUTPUT.totalLen += ropeSet(elems.switchOpt.footerRopes[len(elems.switchOpt.footerRopes)-1], "}break;\n")
                OUTPUT += rope("}break;}\n")
            } else {
                i = 0; for i < len(elems.switchOpt.footerRopes)-1, i++ {
                    OUTPUT.totalLen += ropeSet(elems.switchOpt.footerRopes[i], "")
                }
                OUTPUT.totalLen += ropeSet(elems.switchOpt.footerRopes[len(elems.switchOpt.footerRopes)-1], "}break;\n}\n")

            }

            elems.switchOpt = null

        } else { // Could not optimize, close all else statements
            i=0; for i < compilerState.nbElseIf, i++ {
                OUTPUT += rope("}\n")
            }
        }

        compilerState.nbElseIf = 0
    }
}

//Parses a single line (that can contain a block such as an if statement and its code block).
parseLine(line []Tok, elems Elems*) {

    if len(line) == 0 {
        return
    }

    clear(currChecks)

    line = parsePointers(line, elems)
    ltp = getLineType(line)

    currSetVar = null

    if ltp == LINE_TYPE_VAR && len(line) > 1 {
        ft = line[0]
        st = line[1]
        if st.cont == "=" {
            v = searchVirtVarByToken(&ft, elems)
            currSetVar = v
        }
    }

    afterLineCheck(line, ltp, elems)

    parsed = false
    if ltp == LINE_TYPE_INCLUDE {
        parsed = true
        parseInclude(line, elems)
    } else if ltp == LINE_TYPE_IMPORT {
        parsed = true
        parseImport(line, elems)
    } else if ltp == LINE_TYPE_DEFINE {
        parsed = true
        parseDefine(line, elems)
    } else if ltp == LINE_TYPE_CLIB {
        parsed = true
        parseClib(line)
    } else if ltp == LINE_TYPE_PRE_KEYWORD {
        parsePreKeyword(line, elems)
        parsed = true
    } else {
        OUTPUT += rope("\n#line "+intToStr(line[0].line)+" \""+compilerState.currentFile+"\"\n")
        if ltp == LINE_TYPE_STRUCT {
            parsed = true
            parseStruct(line, elems)
        } else if ltp == LINE_TYPE_CONST {
            parsed = true
            parseConst(line, elems)
        } else if ltp == LINE_TYPE_MACRO {
            return
        } else if ltp != LINE_TYPE_FN_DECL {

            //Transforming 'else if {}'' into C 'else { if {} }'
            //to be able to run code needed for if condition computation
            if ltp == LINE_TYPE_ELSE {
                oswchopt = elems.switchOpt
                elems = dupElems(elems)
                elems.switchOpt = oswchopt
                eh = rope("else{\n")
                OUTPUT += eh
                if elems.switchOpt != null {
                    elems.switchOpt.headerRopes[len(elems.switchOpt.headerRopes)] = eh
                }
                compilerState.nbElseIf++
            }

            line = prePross(line, ltp, elems)
            if len(line) == 0 {
                return
            }
        }

        ft = line[0]
        if ltp == LINE_TYPE_VAR {
            parsed = true
            parseVar(line, elems)
        } else if ltp == LINE_TYPE_FN_CALL {
            if len(line) > 1 {
                throwErr(&line[len(line)-1], "Not expecting {TOKEN} after function call.")
            }
            parsed = true
            if RCPavailable() {
                let fn = searchFuncByToken(&ft, elems) then {
                    if isRCPtype(fn.returns.type, elems) {
                        ft.cont = "RCP_decr("+ft.cont+", 0)"
                    }
                }
            }
            OUTPUT += rope(ft.cont + ";\n")
        } else if ltp == LINE_TYPE_FN_DECL {
            parsed = true
            parseFnDeclare(line, elems)
        } else if ltp == LINE_TYPE_RETURN {
            parsed = true
            parseReturn(line, elems)
        } else if ltp == LINE_TYPE_IF {
            parsed = true
            parseIf(line, false, elems)
        } else if ltp == LINE_TYPE_ELSE {
            parsed = true
            parseElse(line, elems)
        } else if ltp == LINE_TYPE_FOR {
            parsed = true
            parseFor(line, elems)
        } else if ltp == LINE_TYPE_FOR_OPERATOR {
            parsed = true
            parseForOp(line, elems)
        } else if ltp == LINE_TYPE_ASYNC {
            parseAsync(line, elems)
            parsed = true
        } else if ltp == LINE_TYPE_LET {
            parseLet(line, elems)
            parsed = true
        }
    }

    if parsed == false{
        throwErr(&line[0], "{TOKEN} not expected.")
    }

    if len(NEXT_LINE) > 0 {
        OUTPUT += rope(NEXT_LINE)
        NEXT_LINE = ""
    }
    prevLine = ltp


}

hasAnyTok(l []Tok) bool {
    i=0; for i < len(l), i++ {
        if l[i].type == TOKEN_TYPE_CAST && l[i].cont == "<any>" {
            return true
        }
    }
    return false
}

//Parses multiple lines (such as a file).
parseLines(tokens []Tok, elems Elems*) {
    oldnbELIF = compilerState.nbElseIf
    compilerState.nbElseIf = 0

    if len(tokens) == 0 {
        return
    }
    line = []Tok
    ft = tokens[0]
    currentLine = ft.line
    nbEncl = 0
    i=0; for i < len(tokens) {
        t = tokens[i]

        if t.type == TOKEN_TYPE_ENCL {
            if t.cont[0] == '(' || t.cont[0] == '{' || t.cont[0] == '[' {
                nbEncl++
                //skip function body when importing a file
                if shouldOnlyDecl && nbEncl == 1 && t.cont[0] == '{' && len(line) > 1 && line[0].type == TOKEN_TYPE_VAR && line[1].cont == "(" && hasAnyTok(line) == false {
                    line[len(line)] = t
                    i++
                    for i < len(tokens), i++ {
                        t = tokens[i]
                        if t.type != TOKEN_TYPE_ENCL {
                            continue
                        }
                        if t.cont[0] == '(' || t.cont[0] == '{' || t.cont[0] == '[' {
                            nbEncl++
                        } else if t.cont[0] == ')' || t.cont[0] == '}' || t.cont[0] == ']' {
                            nbEncl--
                            if nbEncl == 0 {
                                break
                            }
                        }
                    }
                    t = tokens[i]
                }
            } else if t.cont[0] == ')' || t.cont[0] == '}' || t.cont[0] == ']' {
                nbEncl--
            }
        }

        if t.type == TOKEN_TYPE_STR && t.begLine == currentLine {
            currentLine = t.line
        }

        if nbEncl == 0 {
            if t.line != currentLine {
                if t.type == TOKEN_TYPE_ENCL {
                    line[len(line)] = t
                    pt = tokens[i-1]
                    currentLine = pt.line
                } else {
                    currentLine = t.line
                }
                parseLine(line, elems)
                clear(line)
                if t.type == TOKEN_TYPE_ENCL {
                    i++
                    continue
                }
            } else if t.cont == ";" {
                currentLine = t.line
                parseLine(line, elems)
                clear(line)
                i++
                continue
            }
        }

        line[len(line)] = t
        i++
    }

    if len(line) > 0 {
        if nbEncl == 0 {
            parseLine(line, elems)
            clear(line)
        } else {
            ft = line[len(line)-1]
            throwErr(&ft, "Missing closing token, line ending by {TOKEN}.")
        }
    }
    afterLineCheck(line, LINE_TYPE_NONE, elems)

    if compilerState.nbElseIf > 0 {
        i=0; for i < compilerState.nbElseIf, i++ {
            OUTPUT += rope("}\n")
        }
    }

    compilerState.nbElseIf = oldnbELIF
}

